# PR#20.2: Event Management - Info Button & Events Sheet

**Status:** 📋 **DOCUMENTATION COMPLETE** (Ready for Implementation)  
**Branch**: `feature/pr20.2-event-management` (to be created)  
**Timeline**: 6-8 hours estimated  
**Priority**: 🔵 HIGH - Completes event lifecycle (create → view → manage)  
**Depends on**: PR#20.1 (Proactive Agent) ✅  
**Created**: October 24, 2025

---

## 📋 **Table of Contents**

1. [Overview](#overview)
2. [User Stories](#user-stories)
3. [UI/UX Specification](#uiux-specification)
4. [Technical Architecture](#technical-architecture)
5. [Data Models](#data-models)
6. [Implementation Strategy](#implementation-strategy)
7. [Edge Cases & Error Handling](#edge-cases--error-handling)
8. [Testing Strategy](#testing-strategy)
9. [Success Criteria](#success-criteria)

---

## 🎯 **Overview**

### **Problem**
After PR#20.1, users can CREATE events via Ambient Bar, but:
- ❌ Can't view all events in a conversation (past & future)
- ❌ Can't edit event details (creator needs to fix mistakes)
- ❌ Can't cancel events (plans change!)
- ❌ No way to see who RSVP'd without scrolling through Ambient Bars
- ❌ Past events disappear (no history)

### **Solution**
Add an **Info button** (top right of ChatView) that opens a **full-screen Events Sheet** showing:
- All events (upcoming & past)
- Event details (date, time, location, RSVPs)
- Management actions (edit, cancel for creators)
- Quick actions (add to calendar, change RSVP)

### **Design Philosophy**
**Apple Calendar Style:**
- Clean, minimalist design
- List of events (grouped by time)
- Tap event → See full details
- Clear roles (creator vs participant)

### **Scope**
**In Scope:**
- ✅ Info button UI (top right of ChatView)
- ✅ Events List Sheet (full-screen)
- ✅ Event Detail Modal (tap event)
- ✅ View all events (upcoming & past)
- ✅ Edit event (creator only)
- ✅ Cancel event (creator only)
- ✅ Add to calendar (all users)
- ✅ Change RSVP (participants)
- ✅ Real-time updates (Firestore listeners)

**Out of Scope (Future PRs):**
- ❌ Event reminders/notifications
- ❌ Recurring events
- ❌ Event attachments (images, files)
- ❌ External calendar sync (Google Calendar, etc.)
- ❌ Event chat/comments

---

## 👤 **User Stories**

### **Story 1: View All Events**
**As a** parent in a group chat  
**I want to** see all events we've planned (past & future)  
**So that** I can keep track of our schedule and see what's coming up

**Acceptance Criteria:**
- Tap Info button (top right) → Opens Events Sheet
- See list of all events in conversation
- Events grouped by "Upcoming" and "Past"
- Each event shows: title, date, time, RSVP count
- Tap event → Opens Event Detail Modal

---

### **Story 2: Edit Event (Creator)**
**As an** event creator  
**I want to** edit event details after creating it  
**So that** I can fix mistakes or update plans as they change

**Acceptance Criteria:**
- Open Event Detail → See "Edit Event" button (creator only)
- Tap "Edit Event" → Opens Edit Modal
- Can change: title, date, time, location, notes
- Tap "Save" → Event updates for all users
- All Ambient Bars update in real-time
- System message in chat: "User2 updated Party: New time is 8PM"

---

### **Story 3: Cancel Event (Creator)**
**As an** event creator  
**I want to** cancel an event  
**So that** other parents know the event is no longer happening

**Acceptance Criteria:**
- Open Event Detail → See "Cancel Event" button (creator only)
- Tap "Cancel Event" → Shows confirmation dialog
- Tap "Confirm" → Event status → "cancelled"
- All Ambient Bars dismiss (all users)
- System message in chat: "User2 cancelled Party on Oct 31"
- Event still visible in Events Sheet (with "Cancelled" badge)

---

### **Story 4: Quick Access to Calendar**
**As a** participant  
**I want to** quickly add an event to my iOS Calendar  
**So that** I don't forget about it

**Acceptance Criteria:**
- Open Event Detail → See "Add to Calendar" button
- Tap "Add to Calendar" → Opens iOS Calendar with event pre-filled
- User can confirm/edit before saving
- Button shows "Added ✓" after adding (local state, not synced)

---

### **Story 5: Change RSVP**
**As a** participant  
**I want to** change my RSVP after initially responding  
**So that** I can update my availability if plans change

**Acceptance Criteria:**
- Open Event Detail → See current RSVP status
- Tap "Change Response" → Shows options (Yes/No/Maybe)
- Tap option → RSVP updates in Firestore
- Event Detail refreshes with new RSVP list
- Ambient Bar updates (if still active)

---

## 🎨 **UI/UX Specification**

### **1. Info Button (ChatView Header)**

**Location:** Top right of ChatView (next to AAA button)

**Visual:**
```
┌─────────────────────────────────┐
│ ← Chat Name          ⓘ AAA     │ ← Info button (circle with 'i')
├─────────────────────────────────┤
│                                 │
│  [Chat messages...]             │
│                                 │
```

**Behavior:**
- Tap → Opens Events Sheet (full-screen)
- Badge: Show count if there are active events (e.g., "ⓘ 3")
- Animation: Fade in/out

**Implementation:**
```swift
Button(action: {
    showEventsSheet = true
}) {
    ZStack {
        Image(systemName: "info.circle")
            .font(.title2)
        
        // Badge for event count
        if eventCount > 0 {
            Text("\(eventCount)")
                .font(.caption2)
                .foregroundColor(.white)
                .padding(4)
                .background(Color.red)
                .clipShape(Circle())
                .offset(x: 10, y: -10)
        }
    }
}
.sheet(isPresented: $showEventsSheet) {
    EventsListView(conversationId: conversationId)
}
```

---

### **2. Events List Sheet (Full-Screen)**

**Layout:**
```
┌─────────────────────────────────┐
│  Events                   [Done]│ ← Navigation bar
├─────────────────────────────────┤
│                                 │
│  Upcoming (3)                   │ ← Section header
│  ┌───────────────────────────┐ │
│  │ 📅 Party                   │ │
│  │ Oct 31 at 7PM              │ │
│  │ ✅ 3 going  ❌ 1 no        │ │
│  └───────────────────────────┘ │
│  ┌───────────────────────────┐ │
│  │ 🏊 Swimming                │ │
│  │ Nov 2 at 1PM               │ │
│  │ ⏳ 5 pending               │ │
│  └───────────────────────────┘ │
│  ┌───────────────────────────┐ │
│  │ 🎮 Poker Night             │ │
│  │ Nov 5 at 9PM               │ │
│  │ ✅ 2 going  ⏳ 3 pending   │ │
│  └───────────────────────────┘ │
│                                 │
│  Past (2)                       │ ← Section header
│  ┌───────────────────────────┐ │
│  │ ⚽ Soccer Practice          │ │
│  │ Oct 20 - Completed         │ │
│  │ ✅ 4 attended              │ │
│  └───────────────────────────┘ │
│  ┌───────────────────────────┐ │
│  │ 🎨 Playdate                │ │
│  │ Oct 18 - Completed         │ │
│  │ ✅ 3 attended              │ │
│  └───────────────────────────┘ │
│                                 │
│  [Empty space for scrolling]   │
│                                 │
└─────────────────────────────────┘
```

**Components:**

**Navigation Bar:**
- Title: "Events"
- Right button: "Done" (dismisses sheet)

**Section Headers:**
- "Upcoming (count)" - Events in the future
- "Past (count)" - Events that already happened

**Event Row:**
- Icon: Event type emoji (🎉 📅 🏊 ⚽)
- Title: Event name
- Subtitle: Date & time
- RSVP Summary: Visual indicators (✅ ❌ ⏳)
- Tap → Opens Event Detail Modal

**Empty State:**
```
┌─────────────────────────────────┐
│  Events                   [Done]│
├─────────────────────────────────┤
│                                 │
│         📅                      │
│                                 │
│    No Events Yet                │
│                                 │
│  Events created in this chat    │
│  will appear here               │
│                                 │
└─────────────────────────────────┘
```

**Implementation:**
```swift
struct EventsListView: View {
    let conversationId: String
    @StateObject private var viewModel: EventsListViewModel
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        NavigationView {
            List {
                if !viewModel.upcomingEvents.isEmpty {
                    Section(header: Text("Upcoming (\(viewModel.upcomingEvents.count))")) {
                        ForEach(viewModel.upcomingEvents) { event in
                            EventRowView(event: event)
                                .onTapGesture {
                                    viewModel.selectedEvent = event
                                }
                        }
                    }
                }
                
                if !viewModel.pastEvents.isEmpty {
                    Section(header: Text("Past (\(viewModel.pastEvents.count))")) {
                        ForEach(viewModel.pastEvents) { event in
                            EventRowView(event: event)
                                .onTapGesture {
                                    viewModel.selectedEvent = event
                                }
                        }
                    }
                }
            }
            .navigationTitle("Events")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
            .sheet(item: $viewModel.selectedEvent) { event in
                EventDetailView(event: event)
            }
        }
    }
}
```

---

### **3. Event Detail Modal**

**Layout (Participant View):**
```
┌─────────────────────────────────┐
│          Event Details    [×]   │ ← Header
├─────────────────────────────────┤
│                                 │
│  📅 Party                       │ ← Event icon + title
│  October 31, 2025               │ ← Date (formatted)
│  7:00 PM                        │ ← Time (formatted)
│  📍 John's house                │ ← Location (if provided)
│  👤 Created by User2            │ ← Creator
│                                 │
│  RSVP Status (5)                │ ← Section header
│  ┌───────────────────────────┐ │
│  │ ✅ User1 (Yes)             │ │
│  │ ✅ User2 (Yes)             │ │
│  │ ❌ User3 (No)              │ │
│  │ ⏳ User4 (Pending)         │ │
│  │ ⏳ User5 (Pending)         │ │
│  └───────────────────────────┘ │
│                                 │
│  Your Response: Yes ✅          │ ← Current user's RSVP
│                                 │
│  [📅 Add to Calendar]          │ ← Primary button
│  [🔔 Change Response]          │ ← Secondary button
│                                 │
└─────────────────────────────────┘
```

**Layout (Creator View):**
```
┌─────────────────────────────────┐
│          Event Details    [×]   │
├─────────────────────────────────┤
│                                 │
│  📅 Party                       │
│  October 31, 2025               │
│  7:00 PM                        │
│  📍 John's house                │
│  👤 You created this event      │ ← Different text for creator
│                                 │
│  RSVP Status (5)                │
│  [Same as participant view]     │
│                                 │
│  [📅 Add to Calendar]          │
│  [✏️ Edit Event]               │ ← Creator action
│  [🗑️ Cancel Event]             │ ← Creator action (red)
│                                 │
└─────────────────────────────────┘
```

**Components:**

**Header:**
- Title: "Event Details"
- Right button: Close (×)

**Event Info:**
- Icon: Event type emoji (large, 48pt)
- Title: Event name (font: .title2, bold)
- Date: Formatted (e.g., "October 31, 2025")
- Time: Formatted (e.g., "7:00 PM")
- Location: Optional, with pin icon
- Creator: "Created by [name]" or "You created this event"

**RSVP Section:**
- Header: "RSVP Status (count)"
- List of participants with status:
  - ✅ Green checkmark = Yes
  - ❌ Red X = No
  - ⏳ Yellow clock = Pending/Maybe
- Display names (not user IDs)

**User's Response:**
- "Your Response: [status]" with appropriate emoji
- Highlighted with subtle background color

**Action Buttons:**

**For All Users:**
- "Add to Calendar" (blue, primary button)
  - Icon: 📅
  - Opens iOS Calendar with event

**For Participants:**
- "Change Response" (purple, secondary button)
  - Icon: 🔔
  - Opens action sheet with Yes/No/Maybe options

**For Creator:**
- "Edit Event" (purple, secondary button)
  - Icon: ✏️
  - Opens edit modal
- "Cancel Event" (red, destructive button)
  - Icon: 🗑️
  - Shows confirmation alert

**Implementation:**
```swift
struct EventDetailView: View {
    let event: EventDocument
    @StateObject private var viewModel: EventDetailViewModel
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    // Event info section
                    eventInfoSection
                    
                    Divider()
                    
                    // RSVP section
                    rsvpSection
                    
                    Divider()
                    
                    // Actions section
                    actionsSection
                }
                .padding()
            }
            .navigationTitle("Event Details")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundColor(.gray)
                    }
                }
            }
        }
    }
    
    private var eventInfoSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Icon + Title
            HStack {
                Text(event.icon)
                    .font(.system(size: 48))
                
                Text(event.title)
                    .font(.title2)
                    .fontWeight(.bold)
            }
            
            // Date
            Label(event.formattedDate, systemImage: "calendar")
                .font(.body)
            
            // Time
            Label(event.formattedTime, systemImage: "clock")
                .font(.body)
            
            // Location (if available)
            if let location = event.location, !location.isEmpty {
                Label(location, systemImage: "mappin.and.ellipse")
                    .font(.body)
            }
            
            // Creator
            Label(event.creatorText, systemImage: "person.circle")
                .font(.subheadline)
                .foregroundColor(.secondary)
        }
    }
    
    private var rsvpSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("RSVP Status (\(event.rsvps.count))")
                .font(.headline)
            
            ForEach(Array(event.rsvps.keys.sorted()), id: \.self) { userId in
                if let response = event.rsvps[userId] {
                    HStack {
                        Image(systemName: response.icon)
                            .foregroundColor(response.color)
                        
                        Text(viewModel.displayName(for: userId))
                            .font(.body)
                        
                        Spacer()
                        
                        Text(response.capitalized)
                            .font(.caption)
                            .foregroundColor(response.color)
                    }
                }
            }
            
            // Current user's response (highlighted)
            if let userResponse = event.rsvps[viewModel.currentUserId] {
                HStack {
                    Text("Your Response:")
                        .font(.subheadline)
                        .fontWeight(.semibold)
                    
                    Text(userResponse.capitalized)
                        .font(.subheadline)
                        .foregroundColor(userResponse.color)
                    
                    Image(systemName: userResponse.icon)
                        .foregroundColor(userResponse.color)
                }
                .padding(12)
                .background(userResponse.backgroundColor)
                .cornerRadius(8)
            }
        }
    }
    
    private var actionsSection: some View {
        VStack(spacing: 12) {
            // Add to Calendar (all users)
            Button(action: {
                viewModel.addToCalendar()
            }) {
                Label("Add to Calendar", systemImage: "calendar.badge.plus")
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
            
            // Creator actions
            if viewModel.isCreator {
                Button(action: {
                    viewModel.showEditModal = true
                }) {
                    Label("Edit Event", systemImage: "pencil")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.purple.opacity(0.1))
                        .foregroundColor(.purple)
                        .cornerRadius(10)
                }
                
                Button(action: {
                    viewModel.showCancelConfirmation = true
                }) {
                    Label("Cancel Event", systemImage: "trash")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.red.opacity(0.1))
                        .foregroundColor(.red)
                        .cornerRadius(10)
                }
            } else {
                // Participant action
                Button(action: {
                    viewModel.showChangeRSVP = true
                }) {
                    Label("Change Response", systemImage: "arrow.clockwise")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.purple.opacity(0.1))
                        .foregroundColor(.purple)
                        .cornerRadius(10)
                }
            }
        }
        .sheet(isPresented: $viewModel.showEditModal) {
            EventEditView(event: event)
        }
        .confirmationDialog("Cancel Event", isPresented: $viewModel.showCancelConfirmation) {
            Button("Cancel Event", role: .destructive) {
                viewModel.cancelEvent()
            }
            Button("Keep Event", role: .cancel) {}
        } message: {
            Text("This will cancel the event for all participants. This action cannot be undone.")
        }
        .actionSheet(isPresented: $viewModel.showChangeRSVP) {
            ActionSheet(
                title: Text("Change Your Response"),
                buttons: [
                    .default(Text("✅ Yes, I'll attend")) {
                        viewModel.changeRSVP(to: "yes")
                    },
                    .default(Text("❌ No, can't make it")) {
                        viewModel.changeRSVP(to: "no")
                    },
                    .default(Text("⏳ Maybe")) {
                        viewModel.changeRSVP(to: "maybe")
                    },
                    .cancel()
                ]
            )
        }
    }
}
```

---

### **4. Event Edit Modal (Creator Only)**

**Layout:**
```
┌─────────────────────────────────┐
│  Edit Event        [Cancel][Save]│
├─────────────────────────────────┤
│                                 │
│  Event Title                    │
│  ┌───────────────────────────┐ │
│  │ Party                      │ │
│  └───────────────────────────┘ │
│                                 │
│  Date                           │
│  ┌───────────────────────────┐ │
│  │ October 31, 2025    [📅]  │ │ ← Date picker
│  └───────────────────────────┘ │
│                                 │
│  Time                           │
│  ┌───────────────────────────┐ │
│  │ 7:00 PM             [🕐]  │ │ ← Time picker
│  └───────────────────────────┘ │
│                                 │
│  Location (Optional)            │
│  ┌───────────────────────────┐ │
│  │ John's house               │ │
│  └───────────────────────────┘ │
│                                 │
│  Notes (Optional)               │
│  ┌───────────────────────────┐ │
│  │ Bring snacks and drinks    │ │
│  │                            │ │
│  └───────────────────────────┘ │
│                                 │
└─────────────────────────────────┘
```

**Components:**

**Navigation Bar:**
- Title: "Edit Event"
- Left button: "Cancel" (dismisses without saving)
- Right button: "Save" (saves changes, dismisses)

**Form Fields:**
- Event Title (TextField, required)
- Date (DatePicker, required)
- Time (DatePicker, required)
- Location (TextField, optional)
- Notes (TextEditor, optional, multiline)

**Validation:**
- Title: Cannot be empty
- Date: Must be in the future (or allow past for fixing mistakes?)
- Time: Any time valid
- Save button disabled until all required fields valid

**Behavior:**
- Tap "Cancel" → Shows confirmation if changes made
- Tap "Save" → Updates event in Firestore
- All devices receive update via listener
- System message in chat: "User2 updated Party: New time is 8PM"

**Implementation:**
```swift
struct EventEditView: View {
    @StateObject private var viewModel: EventEditViewModel
    @Environment(\.dismiss) var dismiss
    
    init(event: EventDocument) {
        _viewModel = StateObject(wrappedValue: EventEditViewModel(event: event))
    }
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Event Details")) {
                    TextField("Event Title", text: $viewModel.title)
                    
                    DatePicker("Date", selection: $viewModel.date, displayedComponents: .date)
                    
                    DatePicker("Time", selection: $viewModel.time, displayedComponents: .hourAndMinute)
                }
                
                Section(header: Text("Optional")) {
                    TextField("Location", text: $viewModel.location)
                    
                    TextEditor(text: $viewModel.notes)
                        .frame(height: 100)
                }
            }
            .navigationTitle("Edit Event")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        if viewModel.hasChanges {
                            viewModel.showCancelConfirmation = true
                        } else {
                            dismiss()
                        }
                    }
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Save") {
                        Task {
                            await viewModel.saveChanges()
                            dismiss()
                        }
                    }
                    .disabled(!viewModel.isValid)
                }
            }
            .confirmationDialog("Discard Changes?", isPresented: $viewModel.showCancelConfirmation) {
                Button("Discard", role: .destructive) {
                    dismiss()
                }
                Button("Keep Editing", role: .cancel) {}
            }
        }
    }
}
```

---

## 🏗️ **Technical Architecture**

### **Component Hierarchy**

```
ChatView
├── NavigationBar
│   ├── BackButton
│   ├── ChatTitle
│   └── InfoButton ← NEW
│       └── Badge (if active events > 0)
│
└── Sheet: EventsListView ← NEW
    ├── NavigationBar ("Events", "Done")
    ├── List
    │   ├── Section: "Upcoming"
    │   │   └── ForEach(upcomingEvents)
    │   │       └── EventRowView
    │   └── Section: "Past"
    │       └── ForEach(pastEvents)
    │           └── EventRowView
    │
    └── Sheet: EventDetailView ← NEW
        ├── EventInfoSection
        ├── RSVPSection
        ├── ActionsSection
        │   ├── AddToCalendarButton
        │   ├── EditButton (creator)
        │   ├── CancelButton (creator)
        │   └── ChangeRSVPButton (participant)
        │
        └── Sheet: EventEditView ← NEW
            └── Form (title, date, time, location, notes)
```

### **New Files to Create**

```
messAI/
├── Views/
│   └── Events/                      ← NEW FOLDER
│       ├── EventsListView.swift     (120 lines) ← Main events sheet
│       ├── EventRowView.swift       (80 lines)  ← Reusable row component
│       ├── EventDetailView.swift    (200 lines) ← Event detail modal
│       └── EventEditView.swift      (150 lines) ← Edit modal (creator)
│
├── ViewModels/
│   ├── EventsListViewModel.swift    (150 lines) ← Events list logic
│   ├── EventDetailViewModel.swift   (180 lines) ← Event detail logic
│   └── EventEditViewModel.swift     (120 lines) ← Edit logic
│
└── Models/
    └── EventDocument.swift           (EXTEND EXISTING)
        └── Add computed properties for UI
```

**Total New Code:** ~1,000 lines across 7 files

---

### **Data Flow**

```
┌─────────────────────────────────────────────────────────────┐
│                        User Actions                          │
└──────────────┬──────────────────────────────────────────────┘
               │
               ├─> Tap Info Button
               │   └─> ChatView shows EventsListView sheet
               │       └─> EventsListViewModel fetches events from Firestore
               │           └─> Display events (upcoming & past)
               │
               ├─> Tap Event Row
               │   └─> EventsListView shows EventDetailView modal
               │       └─> EventDetailViewModel fetches event details
               │           └─> Display full event info + RSVPs
               │
               ├─> Tap "Edit Event" (creator)
               │   └─> EventDetailView shows EventEditView modal
               │       └─> EventEditViewModel loads current values
               │           └─> User edits → Tap "Save"
               │               └─> Update Firestore
               │                   └─> Firestore listener notifies all devices
               │                       ├─> Update EventDetailView
               │                       ├─> Update EventsListView
               │                       ├─> Update Ambient Bars
               │                       └─> Send system message to chat
               │
               ├─> Tap "Cancel Event" (creator)
               │   └─> Show confirmation dialog
               │       └─> Confirm → Update event.status = "cancelled"
               │           └─> Firestore listener notifies all devices
               │               ├─> Dismiss all Ambient Bars
               │               ├─> Update EventDetailView
               │               ├─> Update EventsListView
               │               └─> Send system message to chat
               │
               ├─> Tap "Add to Calendar"
               │   └─> Create EKEvent
               │       └─> Open iOS Calendar with event
               │           └─> User confirms → Event added to Calendar
               │
               └─> Tap "Change Response" (participant)
                   └─> Show action sheet (Yes/No/Maybe)
                       └─> Select option → Update Firestore
                           └─> Firestore listener notifies all devices
                               ├─> Update EventDetailView (RSVP list)
                               ├─> Update Ambient Bars (RSVP count)
                               └─> No chat message (silent update)
```

---

### **Firestore Queries**

**1. Fetch All Events for Conversation:**
```swift
// In EventsListViewModel
func loadEvents() async {
    let db = Firestore.firestore()
    
    do {
        let snapshot = try await db.collection("events")
            .whereField("conversationId", isEqualTo: conversationId)
            .order(by: "date", descending: false)  // Oldest first
            .getDocuments()
        
        let allEvents = try snapshot.documents.compactMap { doc in
            try doc.data(as: EventDocument.self)
        }
        
        // Split into upcoming and past
        let now = Date()
        upcomingEvents = allEvents.filter { $0.eventDate >= now && $0.status != "cancelled" }
        pastEvents = allEvents.filter { $0.eventDate < now || $0.status == "cancelled" }
        
    } catch {
        print("❌ Failed to load events: \(error)")
    }
}
```

**2. Listen to Single Event:**
```swift
// In EventDetailViewModel
func startListening(to eventId: String) {
    let db = Firestore.firestore()
    
    listener = db.collection("events").document(eventId)
        .addSnapshotListener { [weak self] snapshot, error in
            guard let self = self else { return }
            
            if let error = error {
                print("❌ Event listener error: \(error)")
                return
            }
            
            guard let data = snapshot?.data() else { return }
            
            do {
                let updatedEvent = try snapshot!.data(as: EventDocument.self)
                
                Task { @MainActor in
                    self.event = updatedEvent
                    self.fetchDisplayNames()
                }
                
            } catch {
                print("❌ Failed to parse event: \(error)")
            }
        }
}
```

**3. Update Event:**
```swift
// In EventEditViewModel
func saveChanges() async throws {
    let db = Firestore.firestore()
    
    let updates: [String: Any] = [
        "title": title,
        "date": dateString,
        "time": timeString,
        "location": location,
        "notes": notes,
        "updatedAt": FieldValue.serverTimestamp()
    ]
    
    try await db.collection("events").document(eventId).updateData(updates)
    
    // Send system message to chat
    await sendSystemMessage("Updated \(title): New time is \(timeString)")
}
```

**4. Cancel Event:**
```swift
// In EventDetailViewModel
func cancelEvent() async {
    let db = Firestore.firestore()
    
    do {
        try await db.collection("events").document(event.id).updateData([
            "status": "cancelled",
            "cancelledAt": FieldValue.serverTimestamp(),
            "cancelledBy": currentUserId
        ])
        
        // Send system message
        await sendSystemMessage("Cancelled \(event.title)")
        
    } catch {
        print("❌ Failed to cancel event: \(error)")
    }
}
```

---

## 📦 **Data Models**

### **Extended EventDocument Model**

**Existing Fields (from PR#20.1):**
```swift
struct EventDocument: Identifiable, Codable {
    let id: String
    let title: String
    let conversationId: String
    let createdBy: String
    let date: String           // "October 31" or "Monday"
    let time: String           // "7PM"
    let location: String?
    let participants: [String]
    let createdAt: Date
    let updatedAt: Date
    let status: String         // "pending", "confirmed", "cancelled"
    var rsvps: [String: String]  // userId -> "yes"/"no"/"maybe"
}
```

**NEW: Computed Properties for UI:**
```swift
extension EventDocument {
    // MARK: - UI Computed Properties
    
    /// Formatted date for display (e.g., "October 31, 2025")
    var formattedDate: String {
        // Parse date string and format nicely
        // Handle "Monday", "October 31", "tomorrow", etc.
    }
    
    /// Formatted time for display (e.g., "7:00 PM")
    var formattedTime: String {
        // Parse time string and format nicely
        // Handle "7PM", "19:00", "2:30PM", etc.
    }
    
    /// Actual Date object for sorting/comparing
    var eventDate: Date {
        // Parse date + time into Date object
        // Use current year if not specified
    }
    
    /// Event icon (emoji)
    var icon: String {
        // Derive from title or eventType
        // "Birthday Party" -> 🎂
        // "Swimming" -> 🏊
        // "Soccer" -> ⚽
        // Default -> 📅
    }
    
    /// Is this event in the future?
    var isUpcoming: Bool {
        return eventDate >= Date() && status != "cancelled"
    }
    
    /// Is this event cancelled?
    var isCancelled: Bool {
        return status == "cancelled"
    }
    
    /// RSVP summary text (e.g., "3 going, 1 can't, 2 pending")
    var rsvpSummary: String {
        let yes = rsvps.values.filter { $0 == "yes" }.count
        let no = rsvps.values.filter { $0 == "no" }.count
        let maybe = rsvps.values.filter { $0 == "maybe" }.count
        let pending = participants.count - rsvps.count
        
        var parts: [String] = []
        if yes > 0 { parts.append("\(yes) going") }
        if no > 0 { parts.append("\(no) can't") }
        if maybe > 0 { parts.append("\(maybe) maybe") }
        if pending > 0 { parts.append("\(pending) pending") }
        
        return parts.joined(separator: ", ")
    }
    
    /// Creator text for UI (e.g., "Created by John" or "You created this event")
    func creatorText(currentUserId: String) -> String {
        if createdBy == currentUserId {
            return "You created this event"
        } else {
            // Fetch display name asynchronously
            return "Created by [User]"  // Placeholder
        }
    }
}
```

### **RSVP Response Enum**

```swift
enum RSVPResponse: String {
    case yes
    case no
    case maybe
    case pending  // Not responded yet
    
    var icon: String {
        switch self {
        case .yes: return "checkmark.circle.fill"
        case .no: return "xmark.circle.fill"
        case .maybe: return "questionmark.circle.fill"
        case .pending: return "clock.fill"
        }
    }
    
    var color: Color {
        switch self {
        case .yes: return .green
        case .no: return .red
        case .maybe: return .yellow
        case .pending: return .gray
        }
    }
    
    var backgroundColor: Color {
        return color.opacity(0.1)
    }
}
```

---

## 🎯 **Implementation Strategy**

### **Phase 1: Basic Infrastructure** (2-3 hours)

**Goal:** Info button → Events List → Event Detail (read-only)

**Steps:**
1. Add Info button to ChatView header
2. Create `EventsListView.swift` (empty state)
3. Create `EventsListViewModel.swift` (fetch events query)
4. Create `EventRowView.swift` (event row component)
5. Create `EventDetailView.swift` (read-only details)
6. Create `EventDetailViewModel.swift` (fetch event, listen to changes)
7. Test: View all events, tap to see details

**Success Criteria:**
- ✅ Info button appears in ChatView header
- ✅ Tapping info button opens Events List sheet
- ✅ Events list shows all events (upcoming & past)
- ✅ Tapping event opens Event Detail modal
- ✅ Event details show all info (date, time, location, RSVPs)

---

### **Phase 2: Calendar Integration** (1 hour)

**Goal:** Add to Calendar button works

**Steps:**
1. Import EventKit
2. Request calendar permissions
3. Implement `addToCalendar()` in `EventDetailViewModel`
4. Create `EKEvent` from `EventDocument`
5. Open iOS Calendar with pre-filled event
6. Test: Add event to calendar, verify it appears

**Success Criteria:**
- ✅ "Add to Calendar" button works
- ✅ iOS Calendar opens with event pre-filled
- ✅ User can confirm and save to calendar
- ✅ Button shows "Added ✓" after adding (local state)

---

### **Phase 3: RSVP Management** (1-2 hours)

**Goal:** Change RSVP for participants

**Steps:**
1. Add "Change Response" button (participants only)
2. Show action sheet with Yes/No/Maybe options
3. Implement `changeRSVP()` in `EventDetailViewModel`
4. Update Firestore `rsvps` map
5. Listen to RSVP changes, update UI
6. Test: Change RSVP, verify updates on all devices

**Success Criteria:**
- ✅ "Change Response" button shows for participants
- ✅ Action sheet shows Yes/No/Maybe options
- ✅ Selecting option updates Firestore
- ✅ Event Detail refreshes with new RSVP list
- ✅ Ambient Bar updates (if active)

---

### **Phase 4: Event Editing** (2-3 hours)

**Goal:** Creators can edit event details

**Steps:**
1. Create `EventEditView.swift` (form with all fields)
2. Create `EventEditViewModel.swift` (edit logic)
3. Add "Edit Event" button (creator only)
4. Implement `saveChanges()` (update Firestore)
5. Send system message to chat ("User2 updated Party")
6. Test: Edit event, verify updates on all devices

**Success Criteria:**
- ✅ "Edit Event" button shows for creator only
- ✅ Tapping opens edit modal with current values
- ✅ Can edit title, date, time, location, notes
- ✅ "Save" updates Firestore
- ✅ System message sent to chat
- ✅ All devices see updated event
- ✅ Ambient Bars update in real-time

---

### **Phase 5: Event Cancellation** (1 hour)

**Goal:** Creators can cancel events

**Steps:**
1. Add "Cancel Event" button (creator only, red/destructive)
2. Show confirmation dialog
3. Implement `cancelEvent()` (update status to "cancelled")
4. Dismiss all Ambient Bars (all users)
5. Send system message to chat ("User2 cancelled Party")
6. Test: Cancel event, verify all devices updated

**Success Criteria:**
- ✅ "Cancel Event" button shows for creator only
- ✅ Tapping shows confirmation dialog
- ✅ Confirming sets event.status = "cancelled"
- ✅ All Ambient Bars dismiss (all users)
- ✅ System message sent to chat
- ✅ Event still visible in Events Sheet (with "Cancelled" badge)

---

### **Phase 6: Polish & Edge Cases** (1-2 hours)

**Goal:** Handle edge cases, loading states, errors

**Steps:**
1. Add loading states (skeleton views)
2. Add empty states (no events)
3. Add error handling (network failures)
4. Add pull-to-refresh (Events List)
5. Add badge count (Info button)
6. Test all edge cases

**Success Criteria:**
- ✅ Loading states show while fetching
- ✅ Empty state shows if no events
- ✅ Error messages show if network fails
- ✅ Pull-to-refresh works in Events List
- ✅ Badge shows count of active events

---

## ⚠️ **Edge Cases & Error Handling**

### **Edge Case 1: No Events in Conversation**

**Scenario:** User taps Info button, but no events have been created yet.

**Expected Behavior:**
- Show empty state in Events List sheet
- Display message: "No Events Yet" with icon
- Sub-message: "Events created in this chat will appear here"

**Implementation:**
```swift
if viewModel.upcomingEvents.isEmpty && viewModel.pastEvents.isEmpty {
    ContentUnavailableView(
        "No Events Yet",
        systemImage: "calendar.badge.questionmark",
        description: Text("Events created in this chat will appear here")
    )
}
```

---

### **Edge Case 2: Event Date/Time Parsing Fails**

**Scenario:** Event has malformed date/time string (e.g., "this weekend" couldn't be parsed).

**Expected Behavior:**
- Show original string as-is (don't crash)
- Sort to bottom of list (treat as unknown date)
- Show warning icon in Event Detail

**Implementation:**
```swift
var eventDate: Date {
    // Try to parse date string
    if let parsed = parseDate(date, time: time) {
        return parsed
    }
    // Fallback: return distant past (sorts to bottom)
    return Date.distantPast
}

var formattedDate: String {
    if eventDate == .distantPast {
        return "\(date) (date unclear)"  // Show original + warning
    }
    return DateFormatter.localizedString(from: eventDate, dateStyle: .medium, timeStyle: .none)
}
```

---

### **Edge Case 3: User Not in Conversation Anymore**

**Scenario:** User was removed from group chat but event still exists.

**Expected Behavior:**
- Show message: "You are no longer in this conversation"
- Disable all actions (can't RSVP, edit, etc.)
- Still allow viewing event (read-only)

**Implementation:**
```swift
// In EventDetailViewModel
var canInteract: Bool {
    return conversation.participantIds.contains(currentUserId)
}

// In UI
if !viewModel.canInteract {
    Text("You are no longer in this conversation")
        .foregroundColor(.secondary)
        .padding()
}
```

---

### **Edge Case 4: Event Creator Leaves Conversation**

**Scenario:** User who created event leaves the group chat.

**Expected Behavior:**
- Event still exists (don't delete)
- No one can edit event (creator gone)
- Participants can still RSVP
- Show "Created by [User] (left)" in Event Detail

**Implementation:**
```swift
func creatorText(currentUserId: String, participants: [String]) -> String {
    if createdBy == currentUserId {
        return "You created this event"
    }
    
    let creatorInChat = participants.contains(createdBy)
    let displayName = // fetch display name
    
    if creatorInChat {
        return "Created by \(displayName)"
    } else {
        return "Created by \(displayName) (left)"
    }
}
```

---

### **Edge Case 5: Rapid Updates (Edit Spam)**

**Scenario:** Creator rapidly edits event multiple times (poor network, accidental taps).

**Expected Behavior:**
- Debounce updates (max 1 update per 2 seconds)
- Show loading indicator while saving
- Disable "Save" button after tap (prevent double-tap)
- If save fails, show error and allow retry

**Implementation:**
```swift
// In EventEditViewModel
@Published var isSaving = false
private var lastSaveTime: Date?

func saveChanges() async throws {
    // Debounce (prevent rapid saves)
    if let lastSave = lastSaveTime, Date().timeIntervalSince(lastSave) < 2.0 {
        print("⚠️ Save debounced (too soon)")
        return
    }
    
    isSaving = true
    defer { isSaving = false }
    
    do {
        try await updateFirestore()
        lastSaveTime = Date()
    } catch {
        // Show error to user
        errorMessage = "Failed to save: \(error.localizedDescription)"
        throw error
    }
}
```

---

### **Edge Case 6: Network Failure**

**Scenario:** User tries to view events while offline.

**Expected Behavior:**
- Show cached events (if available)
- Show "Offline" indicator at top
- Disable edit/cancel actions (require network)
- Allow viewing cached data
- Auto-retry when connection restored

**Implementation:**
```swift
// In EventsListViewModel
@Published var isOffline = false
@Published var cachedEvents: [EventDocument] = []

func loadEvents() async {
    // Check network
    if !NetworkMonitor.shared.isConnected {
        isOffline = true
        // Load from cache
        events = cachedEvents
        return
    }
    
    do {
        events = try await fetchFromFirestore()
        // Cache for offline use
        cachedEvents = events
        isOffline = false
    } catch {
        // Fallback to cache
        events = cachedEvents
        isOffline = true
    }
}
```

---

### **Edge Case 7: iOS Calendar Permission Denied**

**Scenario:** User taps "Add to Calendar" but hasn't granted calendar permissions.

**Expected Behavior:**
- Request permissions (EKEventStore)
- If denied, show alert: "Calendar access required"
- Provide button to open Settings
- Don't crash or fail silently

**Implementation:**
```swift
func addToCalendar() async {
    let eventStore = EKEventStore()
    
    do {
        let granted = try await eventStore.requestFullAccessToEvents()
        
        if granted {
            // Create event and open calendar
            await createCalendarEvent(eventStore)
        } else {
            // Show permission denied alert
            showPermissionAlert = true
        }
    } catch {
        print("❌ Calendar permission error: \(error)")
        errorMessage = "Failed to access calendar"
    }
}
```

---

### **Edge Case 8: Cancelled Event Still Shown**

**Scenario:** Event is cancelled but still appears in Events List and Ambient Bars.

**Expected Behavior:**
- Remove from "Upcoming" section
- Move to "Past" section (even if date is future)
- Show "Cancelled" badge
- Dismiss all Ambient Bars (all users)
- Disable RSVP actions (read-only)

**Implementation:**
```swift
// In EventsListViewModel
func loadEvents() async {
    let allEvents = try await fetchFromFirestore()
    
    // Filter into upcoming and past
    upcomingEvents = allEvents.filter { event in
        return event.status != "cancelled" && event.eventDate >= Date()
    }
    
    pastEvents = allEvents.filter { event in
        return event.status == "cancelled" || event.eventDate < Date()
    }
}
```

---

## 🧪 **Testing Strategy**

### **Unit Tests**

**1. Date/Time Parsing:**
```swift
func testDateParsing() {
    let event = EventDocument(date: "October 31", time: "7PM")
    XCTAssertNotNil(event.eventDate)
    XCTAssertEqual(event.formattedDate, "October 31, 2025")
}

func testMalformedDate() {
    let event = EventDocument(date: "invalid", time: "??")
    XCTAssertEqual(event.eventDate, .distantPast)  // Fallback
}
```

**2. RSVP Summary:**
```swift
func testRSVPSummary() {
    var event = EventDocument(participants: ["u1", "u2", "u3", "u4", "u5"])
    event.rsvps = ["u1": "yes", "u2": "yes", "u3": "no", "u4": "maybe"]
    
    XCTAssertEqual(event.rsvpSummary, "2 going, 1 can't, 1 maybe, 1 pending")
}
```

**3. Event Sorting:**
```swift
func testEventSorting() {
    let events = [
        EventDocument(date: "November 5", status: "pending"),
        EventDocument(date: "October 31", status: "pending"),
        EventDocument(date: "November 2", status: "pending")
    ]
    
    let sorted = events.sorted { $0.eventDate < $1.eventDate }
    XCTAssertEqual(sorted[0].date, "October 31")
    XCTAssertEqual(sorted[1].date, "November 2")
    XCTAssertEqual(sorted[2].date, "November 5")
}
```

---

### **Integration Tests**

**1. Fetch Events:**
```swift
func testFetchEvents() async throws {
    let viewModel = EventsListViewModel(conversationId: testConversationId)
    
    await viewModel.loadEvents()
    
    XCTAssertFalse(viewModel.upcomingEvents.isEmpty)
    XCTAssertTrue(viewModel.upcomingEvents[0].isUpcoming)
}
```

**2. Edit Event:**
```swift
func testEditEvent() async throws {
    let event = EventDocument(id: testEventId, title: "Original")
    let viewModel = EventEditViewModel(event: event)
    
    viewModel.title = "Updated"
    try await viewModel.saveChanges()
    
    // Verify Firestore updated
    let updated = try await fetchEvent(testEventId)
    XCTAssertEqual(updated.title, "Updated")
}
```

**3. Cancel Event:**
```swift
func testCancelEvent() async throws {
    let event = EventDocument(id: testEventId, status: "pending")
    let viewModel = EventDetailViewModel(event: event)
    
    await viewModel.cancelEvent()
    
    // Verify status changed
    let cancelled = try await fetchEvent(testEventId)
    XCTAssertEqual(cancelled.status, "cancelled")
}
```

---

### **UI Tests**

**1. Open Events Sheet:**
```swift
func testOpenEventsSheet() throws {
    let app = XCUIApplication()
    app.launch()
    
    // Navigate to chat
    app.tables.staticTexts["Test Chat"].tap()
    
    // Tap info button
    app.navigationBars.buttons["Info"].tap()
    
    // Verify sheet opened
    XCTAssertTrue(app.navigationBars["Events"].exists)
}
```

**2. View Event Details:**
```swift
func testViewEventDetails() throws {
    let app = XCUIApplication()
    
    // Open events sheet
    app.navigationBars.buttons["Info"].tap()
    
    // Tap first event
    app.tables.cells.element(boundBy: 0).tap()
    
    // Verify detail modal opened
    XCTAssertTrue(app.navigationBars["Event Details"].exists)
    XCTAssertTrue(app.buttons["Add to Calendar"].exists)
}
```

**3. Edit Event (Creator):**
```swift
func testEditEvent() throws {
    let app = XCUIApplication()
    
    // Navigate to event detail
    app.navigationBars.buttons["Info"].tap()
    app.tables.cells.element(boundBy: 0).tap()
    
    // Tap edit button (creator only)
    app.buttons["Edit Event"].tap()
    
    // Verify edit modal opened
    XCTAssertTrue(app.navigationBars["Edit Event"].exists)
    
    // Edit title
    let titleField = app.textFields["Event Title"]
    titleField.tap()
    titleField.typeText(" Updated")
    
    // Save
    app.navigationBars.buttons["Save"].tap()
    
    // Verify dismissed
    XCTAssertFalse(app.navigationBars["Edit Event"].exists)
}
```

---

### **Manual Testing Checklist**

**Scenario 1: View Events**
- [ ] Tap Info button → Events sheet opens
- [ ] See all events (upcoming & past)
- [ ] Tap event → Event detail modal opens
- [ ] See all info (date, time, location, RSVPs)
- [ ] Tap "Done" → Sheet dismisses

**Scenario 2: Add to Calendar**
- [ ] Open event detail
- [ ] Tap "Add to Calendar"
- [ ] iOS Calendar opens with event
- [ ] Confirm → Event added to calendar
- [ ] Button shows "Added ✓"

**Scenario 3: Edit Event (Creator)**
- [ ] Open event detail (as creator)
- [ ] Tap "Edit Event"
- [ ] Edit title, date, time
- [ ] Tap "Save"
- [ ] Event updates on all devices
- [ ] System message appears in chat
- [ ] Ambient Bar updates

**Scenario 4: Cancel Event (Creator)**
- [ ] Open event detail (as creator)
- [ ] Tap "Cancel Event"
- [ ] See confirmation dialog
- [ ] Tap "Confirm"
- [ ] All Ambient Bars dismiss (all users)
- [ ] Event moves to "Past" section
- [ ] System message appears in chat

**Scenario 5: Change RSVP (Participant)**
- [ ] Open event detail (as participant)
- [ ] Tap "Change Response"
- [ ] See action sheet (Yes/No/Maybe)
- [ ] Select "Yes"
- [ ] RSVP list updates
- [ ] Ambient Bar updates (RSVP count)
- [ ] No chat message (silent update)

**Scenario 6: Real-Time Updates**
- [ ] Two devices, same chat
- [ ] Device 1: Edit event
- [ ] Device 2: See update immediately (<500ms)
- [ ] Both devices show same info

**Scenario 7: Offline Handling**
- [ ] Turn off network
- [ ] Open Events sheet
- [ ] See cached events
- [ ] See "Offline" indicator
- [ ] Try to edit → Error message
- [ ] Turn on network
- [ ] Auto-refresh works

---

## ✅ **Success Criteria**

**Functional Requirements:**
- ✅ Info button visible in ChatView header
- ✅ Info button opens Events List sheet
- ✅ Events List shows all events (upcoming & past)
- ✅ Tapping event opens Event Detail modal
- ✅ Event Detail shows all info + RSVPs
- ✅ Creator can edit event (title, date, time, location, notes)
- ✅ Creator can cancel event (with confirmation)
- ✅ All users can add event to iOS Calendar
- ✅ Participants can change RSVP (Yes/No/Maybe)
- ✅ Real-time updates (<500ms latency)

**Non-Functional Requirements:**
- ✅ Clean, Apple-style UI (matches iOS design guidelines)
- ✅ Smooth animations (sheet transitions, updates)
- ✅ Fast performance (<100ms to open sheet)
- ✅ Handles edge cases gracefully (no crashes)
- ✅ Clear error messages (network failures, permissions)
- ✅ Accessible (VoiceOver support, dynamic type)

**Code Quality:**
- ✅ Clean MVVM architecture (separation of concerns)
- ✅ Reusable components (EventRowView, etc.)
- ✅ Comprehensive error handling (try/catch, fallbacks)
- ✅ Comprehensive logging (debug flow)
- ✅ Unit tests (date parsing, RSVP logic)
- ✅ Integration tests (Firestore CRUD)
- ✅ UI tests (user flows)

---

## 📊 **Estimated Complexity**

**Overall Complexity:** Medium-High

**Breakdown:**
- **UI Complexity:** Medium (3 new views, standard patterns)
- **Logic Complexity:** Medium (Firestore CRUD, listeners, permissions)
- **Integration Complexity:** Medium (EventKit, real-time sync)

**Risks:**
- ⚠️ Date/time parsing (many formats to handle)
- ⚠️ Real-time sync complexity (multiple devices)
- ⚠️ iOS Calendar permissions (user may deny)

**Total Estimated Time:** 6-8 hours

**Timeline Breakdown:**
- Phase 1: Basic Infrastructure (2-3 hours)
- Phase 2: Calendar Integration (1 hour)
- Phase 3: RSVP Management (1-2 hours)
- Phase 4: Event Editing (2-3 hours)
- Phase 5: Event Cancellation (1 hour)
- Phase 6: Polish & Edge Cases (1-2 hours)

---

## 🎯 **Next Steps**

**After Documentation Approval:**
1. Create branch: `feature/pr20.2-event-management`
2. Implement Phase 1 (Basic Infrastructure)
3. Test Phase 1 thoroughly
4. Implement Phase 2 (Calendar Integration)
5. Continue through all phases
6. Comprehensive testing
7. Create PR & merge

**Dependencies:**
- ✅ PR#20.1 (Proactive Agent) - COMPLETE
- ✅ Event creation via Ambient Bar - WORKING
- ✅ Firestore event documents - EXIST

**Ready to implement!** 🚀

