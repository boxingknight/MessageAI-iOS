# PR#20.2: Event Management - Implementation Checklist

**Status:** üìã **READY FOR IMPLEMENTATION**  
**Branch**: `feature/pr20.2-event-management`  
**Estimated Time**: 6-8 hours  
**Last Updated**: October 24, 2025

---

## üìã **Pre-Implementation Checklist**

**Before writing any code, verify:**
- [ ] PR#20.1 (Proactive Agent) is merged to main
- [ ] No outstanding linter errors in existing code
- [ ] Firebase indexes are built (events collection)
- [ ] All tests passing on main branch
- [ ] Branch created: `feature/pr20.2-event-management`

---

## üèóÔ∏è **Phase 1: Basic Infrastructure** (2-3 hours)

### **Task 1.1: Extend EventDocument Model**

**File:** `messAI/Models/EventDocument.swift`

**Changes:**
- [ ] Add computed property: `formattedDate: String`
  - Parse "October 31" ‚Üí "October 31, 2025"
  - Parse "Monday" ‚Üí "Monday, October 27"
  - Handle "tomorrow" ‚Üí "Tomorrow, October 25"
- [ ] Add computed property: `formattedTime: String`
  - Parse "7PM" ‚Üí "7:00 PM"
  - Parse "19:00" ‚Üí "7:00 PM"
  - Parse "2:30PM" ‚Üí "2:30 PM"
- [ ] Add computed property: `eventDate: Date`
  - Combine date + time into Date object
  - Handle parsing failures (return .distantPast)
- [ ] Add computed property: `icon: String`
  - Map event types to emojis
  - "Birthday" ‚Üí üéÇ, "Swimming" ‚Üí üèä, "Soccer" ‚Üí ‚öΩ
  - Default ‚Üí üìÖ
- [ ] Add computed property: `isUpcoming: Bool`
  - Return `eventDate >= Date() && status != "cancelled"`
- [ ] Add computed property: `isCancelled: Bool`
  - Return `status == "cancelled"`
- [ ] Add computed property: `rsvpSummary: String`
  - Count yes/no/maybe/pending
  - Return "3 going, 1 can't, 2 pending"
- [ ] Add method: `creatorText(currentUserId:) -> String`
  - Return "You created this event" if creator
  - Return "Created by [name]" otherwise
- [ ] Add new fields to Firestore schema (if missing):
  - `updatedAt: Date`
  - `cancelledAt: Date?`
  - `cancelledBy: String?`

**Testing:**
```swift
// Test date parsing
let event1 = EventDocument(date: "October 31", time: "7PM")
XCTAssertEqual(event1.formattedDate, "October 31, 2025")
XCTAssertEqual(event1.formattedTime, "7:00 PM")

// Test malformed dates
let event2 = EventDocument(date: "invalid", time: "??")
XCTAssertEqual(event2.eventDate, .distantPast)

// Test RSVP summary
var event3 = EventDocument(participants: ["u1", "u2", "u3"])
event3.rsvps = ["u1": "yes", "u2": "no"]
XCTAssertEqual(event3.rsvpSummary, "1 going, 1 can't, 1 pending")
```

---

### **Task 1.2: Create EventsListViewModel**

**File:** `messAI/ViewModels/EventsListViewModel.swift` (NEW)

**Implementation:**
```swift
import Foundation
import FirebaseFirestore
import Combine

@MainActor
class EventsListViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var upcomingEvents: [EventDocument] = []
    @Published var pastEvents: [EventDocument] = []
    @Published var selectedEvent: EventDocument?
    @Published var isLoading = false
    @Published var isOffline = false
    @Published var errorMessage: String?
    
    // MARK: - Private Properties
    private let conversationId: String
    private var listener: ListenerRegistration?
    private var cachedEvents: [EventDocument] = []
    
    // MARK: - Initialization
    init(conversationId: String) {
        self.conversationId = conversationId
    }
    
    deinit {
        listener?.remove()
    }
    
    // MARK: - Public Methods
    
    /// Start listening to events for this conversation
    func startListening() {
        // TODO: Implement Firestore listener
    }
    
    /// Load events once (no listener)
    func loadEvents() async {
        // TODO: Implement fetch from Firestore
    }
    
    /// Refresh events (pull-to-refresh)
    func refresh() async {
        // TODO: Reload from Firestore
    }
    
    // MARK: - Private Methods
    
    private func processEvents(_ events: [EventDocument]) {
        let now = Date()
        
        // Split into upcoming and past
        upcomingEvents = events.filter { event in
            return event.status != "cancelled" && event.eventDate >= now
        }.sorted { $0.eventDate < $1.eventDate }
        
        pastEvents = events.filter { event in
            return event.status == "cancelled" || event.eventDate < now
        }.sorted { $0.eventDate > $1.eventDate }  // Descending (recent first)
    }
}
```

**Checklist:**
- [ ] Create file with class structure
- [ ] Add `@Published` properties
- [ ] Implement `startListening()` with Firestore listener
- [ ] Implement `loadEvents()` for initial fetch
- [ ] Implement `processEvents()` to split upcoming/past
- [ ] Add error handling (try/catch)
- [ ] Add offline handling (check NetworkMonitor)
- [ ] Add caching (save to `cachedEvents`)
- [ ] Test: Fetch events, verify split correctly

---

### **Task 1.3: Create EventRowView**

**File:** `messAI/Views/Events/EventRowView.swift` (NEW)

**Implementation:**
```swift
import SwiftUI

struct EventRowView: View {
    let event: EventDocument
    
    var body: some View {
        HStack(spacing: 12) {
            // Event icon
            Text(event.icon)
                .font(.system(size: 32))
            
            VStack(alignment: .leading, spacing: 4) {
                // Event title
                Text(event.title)
                    .font(.headline)
                    .foregroundColor(.primary)
                
                // Date & time
                Text("\(event.formattedDate) at \(event.formattedTime)")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                
                // RSVP summary
                if !event.rsvpSummary.isEmpty {
                    Text(event.rsvpSummary)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            
            Spacer()
            
            // Cancelled badge (if applicable)
            if event.isCancelled {
                Text("Cancelled")
                    .font(.caption2)
                    .fontWeight(.semibold)
                    .foregroundColor(.white)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(Color.red)
                    .cornerRadius(8)
            }
        }
        .padding(.vertical, 8)
    }
}

#Preview {
    EventRowView(event: EventDocument(
        id: "1",
        title: "Party",
        conversationId: "c1",
        createdBy: "u1",
        date: "October 31",
        time: "7PM",
        location: "John's house",
        participants: ["u1", "u2", "u3"],
        createdAt: Date(),
        updatedAt: Date(),
        status: "pending",
        rsvps: ["u1": "yes", "u2": "no"]
    ))
}
```

**Checklist:**
- [ ] Create SwiftUI view with HStack layout
- [ ] Display event icon (emoji, large)
- [ ] Display event title (headline)
- [ ] Display date & time (subheadline)
- [ ] Display RSVP summary (caption)
- [ ] Add "Cancelled" badge if applicable
- [ ] Add preview provider
- [ ] Test: View renders correctly in preview

---

### **Task 1.4: Create EventsListView**

**File:** `messAI/Views/Events/EventsListView.swift` (NEW)

**Implementation:**
```swift
import SwiftUI

struct EventsListView: View {
    let conversationId: String
    
    @StateObject private var viewModel: EventsListViewModel
    @Environment(\.dismiss) var dismiss
    
    init(conversationId: String) {
        self.conversationId = conversationId
        _viewModel = StateObject(wrappedValue: EventsListViewModel(conversationId: conversationId))
    }
    
    var body: some View {
        NavigationView {
            ZStack {
                if viewModel.isLoading {
                    ProgressView()
                } else if viewModel.upcomingEvents.isEmpty && viewModel.pastEvents.isEmpty {
                    emptyState
                } else {
                    eventsList
                }
            }
            .navigationTitle("Events")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
            .sheet(item: $viewModel.selectedEvent) { event in
                EventDetailView(event: event, conversationId: conversationId)
            }
        }
        .onAppear {
            viewModel.startListening()
        }
    }
    
    private var emptyState: some View {
        ContentUnavailableView(
            "No Events Yet",
            systemImage: "calendar.badge.questionmark",
            description: Text("Events created in this chat will appear here")
        )
    }
    
    private var eventsList: some View {
        List {
            // Upcoming events
            if !viewModel.upcomingEvents.isEmpty {
                Section(header: Text("Upcoming (\(viewModel.upcomingEvents.count))")) {
                    ForEach(viewModel.upcomingEvents) { event in
                        EventRowView(event: event)
                            .onTapGesture {
                                viewModel.selectedEvent = event
                            }
                    }
                }
            }
            
            // Past events
            if !viewModel.pastEvents.isEmpty {
                Section(header: Text("Past (\(viewModel.pastEvents.count))")) {
                    ForEach(viewModel.pastEvents) { event in
                        EventRowView(event: event)
                            .onTapGesture {
                                viewModel.selectedEvent = event
                            }
                    }
                }
            }
        }
        .refreshable {
            await viewModel.refresh()
        }
    }
}
```

**Checklist:**
- [ ] Create SwiftUI view with NavigationView
- [ ] Initialize `EventsListViewModel`
- [ ] Add loading state (ProgressView)
- [ ] Add empty state (ContentUnavailableView)
- [ ] Add sections for "Upcoming" and "Past"
- [ ] Use `EventRowView` for each event
- [ ] Add "Done" button (dismiss sheet)
- [ ] Add pull-to-refresh
- [ ] Open `EventDetailView` on tap
- [ ] Call `startListening()` on appear
- [ ] Test: Open sheet, see events

---

### **Task 1.5: Create EventDetailViewModel**

**File:** `messAI/ViewModels/EventDetailViewModel.swift` (NEW)

**Implementation:**
```swift
import Foundation
import FirebaseFirestore
import FirebaseAuth
import EventKit

@MainActor
class EventDetailViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var event: EventDocument
    @Published var displayNames: [String: String] = [:]  // userId -> displayName
    @Published var isCreator = false
    @Published var currentUserRSVP: String?
    @Published var errorMessage: String?
    @Published var showEditModal = false
    @Published var showCancelConfirmation = false
    @Published var showChangeRSVP = false
    @Published var isAddedToCalendar = false
    
    // MARK: - Private Properties
    private let conversationId: String
    private var currentUserId: String {
        return Auth.auth().currentUser?.uid ?? ""
    }
    private var listener: ListenerRegistration?
    
    // MARK: - Initialization
    init(event: EventDocument, conversationId: String) {
        self.event = event
        self.conversationId = conversationId
        self.isCreator = (event.createdBy == Auth.auth().currentUser?.uid)
        self.currentUserRSVP = event.rsvps[Auth.auth().currentUser?.uid ?? ""]
    }
    
    deinit {
        listener?.remove()
    }
    
    // MARK: - Public Methods
    
    func startListening() {
        // TODO: Listen to event updates
    }
    
    func fetchDisplayNames() async {
        // TODO: Fetch display names for all participants
    }
    
    func addToCalendar() async {
        // TODO: Implement (Phase 2)
    }
    
    func changeRSVP(to response: String) async {
        // TODO: Implement (Phase 3)
    }
    
    func cancelEvent() async {
        // TODO: Implement (Phase 5)
    }
}
```

**Checklist:**
- [ ] Create file with class structure
- [ ] Add `@Published` properties
- [ ] Implement `startListening()` with Firestore listener
- [ ] Implement `fetchDisplayNames()` to get user names
- [ ] Add computed property `creatorText`
- [ ] Stub out methods for later phases
- [ ] Test: Open event detail, see info

---

### **Task 1.6: Create EventDetailView**

**File:** `messAI/Views/Events/EventDetailView.swift` (NEW)

**Implementation:**
```swift
import SwiftUI

struct EventDetailView: View {
    let conversationId: String
    
    @StateObject private var viewModel: EventDetailViewModel
    @Environment(\.dismiss) var dismiss
    
    init(event: EventDocument, conversationId: String) {
        self.conversationId = conversationId
        _viewModel = StateObject(wrappedValue: EventDetailViewModel(event: event, conversationId: conversationId))
    }
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    eventInfoSection
                    Divider()
                    rsvpSection
                    Divider()
                    actionsSection
                }
                .padding()
            }
            .navigationTitle("Event Details")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundColor(.gray)
                    }
                }
            }
        }
        .onAppear {
            viewModel.startListening()
            Task {
                await viewModel.fetchDisplayNames()
            }
        }
    }
    
    private var eventInfoSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Icon + Title
            HStack {
                Text(viewModel.event.icon)
                    .font(.system(size: 48))
                
                Text(viewModel.event.title)
                    .font(.title2)
                    .fontWeight(.bold)
            }
            
            // Date
            Label(viewModel.event.formattedDate, systemImage: "calendar")
                .font(.body)
            
            // Time
            Label(viewModel.event.formattedTime, systemImage: "clock")
                .font(.body)
            
            // Location (if available)
            if let location = viewModel.event.location, !location.isEmpty {
                Label(location, systemImage: "mappin.and.ellipse")
                    .font(.body)
            }
            
            // Creator
            Label(viewModel.event.creatorText(currentUserId: viewModel.currentUserId), systemImage: "person.circle")
                .font(.subheadline)
                .foregroundColor(.secondary)
        }
    }
    
    private var rsvpSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("RSVP Status (\(viewModel.event.rsvps.count))")
                .font(.headline)
            
            // TODO: Display RSVP list with display names
            // Placeholder for now
            Text("RSVP list will appear here")
                .font(.subheadline)
                .foregroundColor(.secondary)
        }
    }
    
    private var actionsSection: some View {
        VStack(spacing: 12) {
            // Placeholder buttons (will implement in later phases)
            Button(action: {}) {
                Label("Add to Calendar", systemImage: "calendar.badge.plus")
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
            .disabled(true)  // Enable in Phase 2
        }
    }
}
```

**Checklist:**
- [ ] Create SwiftUI view with NavigationView + ScrollView
- [ ] Initialize `EventDetailViewModel`
- [ ] Implement `eventInfoSection` (icon, title, date, time, location, creator)
- [ ] Implement `rsvpSection` (placeholder for now)
- [ ] Implement `actionsSection` (placeholder buttons, disabled)
- [ ] Add close button (√ó) in toolbar
- [ ] Call `startListening()` and `fetchDisplayNames()` on appear
- [ ] Test: Open event detail, see all info

---

### **Task 1.7: Add Info Button to ChatView**

**File:** `messAI/Views/Chat/ChatView.swift`

**Changes:**
```swift
@State private var showEventsSheet = false

var body: some View {
    VStack(spacing: 0) {
        // ... existing code ...
    }
    .navigationBarTitleDisplayMode(.inline)
    .toolbar {
        // ... existing toolbar items ...
        
        // NEW: Info button
        ToolbarItem(placement: .navigationBarTrailing) {
            Button(action: {
                showEventsSheet = true
            }) {
                Image(systemName: "info.circle")
                    .font(.title2)
            }
        }
    }
    .sheet(isPresented: $showEventsSheet) {
        EventsListView(conversationId: viewModel.conversationId)
    }
}
```

**Checklist:**
- [ ] Add `@State` variable `showEventsSheet`
- [ ] Add Info button to toolbar (top right)
- [ ] Use `info.circle` SF Symbol
- [ ] Add `.sheet()` modifier
- [ ] Open `EventsListView` when tapped
- [ ] Test: Tap button, sheet opens

---

### **Task 1.8: Phase 1 Testing**

**Manual Tests:**
- [ ] Tap Info button ‚Üí Events sheet opens
- [ ] See empty state (if no events)
- [ ] See list of events (if events exist)
- [ ] Events split into "Upcoming" and "Past" sections
- [ ] Tap event ‚Üí Event detail modal opens
- [ ] See event info (date, time, location, creator)
- [ ] Close modal ‚Üí Return to events list
- [ ] Close sheet ‚Üí Return to chat

**Automated Tests:**
- [ ] Unit test: `EventDocument.formattedDate`
- [ ] Unit test: `EventDocument.formattedTime`
- [ ] Unit test: `EventDocument.eventDate`
- [ ] Unit test: `EventDocument.rsvpSummary`
- [ ] Integration test: `EventsListViewModel.loadEvents()`
- [ ] UI test: Open events sheet

---

## üóìÔ∏è **Phase 2: Calendar Integration** (1 hour)

### **Task 2.1: Request Calendar Permissions**

**File:** `messAI/Info.plist`

**Changes:**
- [ ] Add key: `NSCalendarsFullAccessUsageDescription`
- [ ] Value: "MessAI needs access to your calendar to add events"

**File:** `messAI/Services/CalendarManager.swift` (existing)

**Changes:**
- [ ] Verify `requestCalendarAccess()` method exists
- [ ] Test: Request permissions, verify dialog appears

---

### **Task 2.2: Implement Add to Calendar**

**File:** `messAI/ViewModels/EventDetailViewModel.swift`

**Implementation:**
```swift
func addToCalendar() async {
    let eventStore = EKEventStore()
    
    do {
        // Request permissions
        let granted = try await eventStore.requestFullAccessToEvents()
        
        guard granted else {
            errorMessage = "Calendar access denied. Please enable in Settings."
            return
        }
        
        // Create EKEvent
        let ekEvent = EKEvent(eventStore: eventStore)
        ekEvent.title = event.title
        ekEvent.startDate = event.eventDate
        ekEvent.endDate = event.eventDate.addingTimeInterval(3600)  // 1 hour duration
        ekEvent.notes = event.location
        ekEvent.calendar = eventStore.defaultCalendarForNewEvents
        
        // Save to calendar
        try eventStore.save(ekEvent, span: .thisEvent)
        
        // Update UI
        isAddedToCalendar = true
        
        print("‚úÖ Event added to calendar: \(event.title)")
        
    } catch {
        errorMessage = "Failed to add event to calendar: \(error.localizedDescription)"
        print("‚ùå Calendar error: \(error)")
    }
}
```

**Checklist:**
- [ ] Import EventKit
- [ ] Implement `addToCalendar()` method
- [ ] Request calendar permissions
- [ ] Create `EKEvent` from `EventDocument`
- [ ] Set title, startDate, endDate, notes
- [ ] Save to default calendar
- [ ] Set `isAddedToCalendar = true` on success
- [ ] Handle errors gracefully

---

### **Task 2.3: Update EventDetailView UI**

**File:** `messAI/Views/Events/EventDetailView.swift`

**Changes:**
```swift
private var actionsSection: some View {
    VStack(spacing: 12) {
        // Add to Calendar button
        Button(action: {
            Task {
                await viewModel.addToCalendar()
            }
        }) {
            HStack {
                Image(systemName: viewModel.isAddedToCalendar ? "checkmark.circle.fill" : "calendar.badge.plus")
                Text(viewModel.isAddedToCalendar ? "Added to Calendar" : "Add to Calendar")
            }
            .frame(maxWidth: .infinity)
            .padding()
            .background(viewModel.isAddedToCalendar ? Color.green : Color.blue)
            .foregroundColor(.white)
            .cornerRadius(10)
        }
        .disabled(viewModel.isAddedToCalendar)
        
        // Error message (if any)
        if let error = viewModel.errorMessage {
            Text(error)
                .font(.caption)
                .foregroundColor(.red)
                .padding(.horizontal)
        }
    }
}
```

**Checklist:**
- [ ] Enable "Add to Calendar" button
- [ ] Change text to "Added ‚úì" after adding
- [ ] Disable button after adding (prevent duplicates)
- [ ] Show error message if permission denied
- [ ] Test: Add event to calendar, verify it appears

---

### **Task 2.4: Phase 2 Testing**

**Manual Tests:**
- [ ] Open event detail
- [ ] Tap "Add to Calendar"
- [ ] iOS Calendar opens (or permission dialog)
- [ ] Grant permission
- [ ] Event added to calendar
- [ ] Button shows "Added ‚úì"
- [ ] Open iOS Calendar app
- [ ] Verify event exists

---

## üìù **Phase 3: RSVP Management** (1-2 hours)

### **Task 3.1: Implement Change RSVP**

**File:** `messAI/ViewModels/EventDetailViewModel.swift`

**Implementation:**
```swift
func changeRSVP(to response: String) async {
    let db = Firestore.firestore()
    
    do {
        // Update Firestore
        try await db.collection("events").document(event.id).updateData([
            "rsvps.\(currentUserId)": response,
            "updatedAt": FieldValue.serverTimestamp()
        ])
        
        // Update local state
        event.rsvps[currentUserId] = response
        currentUserRSVP = response
        
        print("‚úÖ RSVP updated to: \(response)")
        
    } catch {
        errorMessage = "Failed to update RSVP: \(error.localizedDescription)"
        print("‚ùå RSVP update failed: \(error)")
    }
}
```

**Checklist:**
- [ ] Implement `changeRSVP(to:)` method
- [ ] Update Firestore `rsvps` map
- [ ] Update local `event.rsvps`
- [ ] Update `currentUserRSVP`
- [ ] Handle errors gracefully

---

### **Task 3.2: Display RSVP List**

**File:** `messAI/Views/Events/EventDetailView.swift`

**Changes:**
```swift
private var rsvpSection: some View {
    VStack(alignment: .leading, spacing: 12) {
        Text("RSVP Status (\(viewModel.event.rsvps.count))")
            .font(.headline)
        
        // Display each RSVP
        ForEach(Array(viewModel.event.rsvps.keys.sorted()), id: \.self) { userId in
            if let response = viewModel.event.rsvps[userId] {
                HStack {
                    Image(systemName: rsvpIcon(for: response))
                        .foregroundColor(rsvpColor(for: response))
                    
                    Text(viewModel.displayNames[userId] ?? userId)
                        .font(.body)
                    
                    Spacer()
                    
                    Text(response.capitalized)
                        .font(.caption)
                        .foregroundColor(rsvpColor(for: response))
                }
            }
        }
        
        // Current user's response (highlighted)
        if let userResponse = viewModel.currentUserRSVP {
            HStack {
                Text("Your Response:")
                    .font(.subheadline)
                    .fontWeight(.semibold)
                
                Text(userResponse.capitalized)
                    .font(.subheadline)
                    .foregroundColor(rsvpColor(for: userResponse))
                
                Image(systemName: rsvpIcon(for: userResponse))
                    .foregroundColor(rsvpColor(for: userResponse))
            }
            .padding(12)
            .background(rsvpColor(for: userResponse).opacity(0.1))
            .cornerRadius(8)
        }
    }
}

private func rsvpIcon(for response: String) -> String {
    switch response {
    case "yes": return "checkmark.circle.fill"
    case "no": return "xmark.circle.fill"
    case "maybe": return "questionmark.circle.fill"
    default: return "clock.fill"
    }
}

private func rsvpColor(for response: String) -> Color {
    switch response {
    case "yes": return .green
    case "no": return .red
    case "maybe": return .yellow
    default: return .gray
    }
}
```

**Checklist:**
- [ ] Display RSVP list with icons and colors
- [ ] Show display names (not user IDs)
- [ ] Highlight current user's response
- [ ] Add helper methods for icons/colors

---

### **Task 3.3: Add Change RSVP Button**

**File:** `messAI/Views/Events/EventDetailView.swift`

**Changes:**
```swift
private var actionsSection: some View {
    VStack(spacing: 12) {
        // Add to Calendar button
        // ... existing code ...
        
        // Change RSVP button (participants only)
        if !viewModel.isCreator {
            Button(action: {
                viewModel.showChangeRSVP = true
            }) {
                Label("Change Response", systemImage: "arrow.clockwise")
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.purple.opacity(0.1))
                    .foregroundColor(.purple)
                    .cornerRadius(10)
            }
        }
    }
    .actionSheet(isPresented: $viewModel.showChangeRSVP) {
        ActionSheet(
            title: Text("Change Your Response"),
            buttons: [
                .default(Text("‚úÖ Yes, I'll attend")) {
                    Task {
                        await viewModel.changeRSVP(to: "yes")
                    }
                },
                .default(Text("‚ùå No, can't make it")) {
                    Task {
                        await viewModel.changeRSVP(to: "no")
                    }
                },
                .default(Text("‚è≥ Maybe")) {
                    Task {
                        await viewModel.changeRSVP(to: "maybe")
                    }
                },
                .cancel()
            ]
        )
    }
}
```

**Checklist:**
- [ ] Add "Change Response" button (participants only)
- [ ] Show action sheet with Yes/No/Maybe options
- [ ] Call `changeRSVP(to:)` on selection
- [ ] Test: Change RSVP, verify updates

---

### **Task 3.4: Phase 3 Testing**

**Manual Tests:**
- [ ] Open event detail (as participant)
- [ ] See current RSVP status
- [ ] Tap "Change Response"
- [ ] See action sheet
- [ ] Select "Yes" ‚Üí RSVP updates
- [ ] RSVP list refreshes
- [ ] Second device sees update (<500ms)

---

## ‚úèÔ∏è **Phase 4: Event Editing** (2-3 hours)

### **Task 4.1: Create EventEditViewModel**

**File:** `messAI/ViewModels/EventEditViewModel.swift` (NEW)

**Implementation:**
```swift
import Foundation
import FirebaseFirestore
import FirebaseAuth

@MainActor
class EventEditViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var title: String
    @Published var date: Date
    @Published var time: Date
    @Published var location: String
    @Published var notes: String
    @Published var isSaving = false
    @Published var errorMessage: String?
    @Published var showCancelConfirmation = false
    
    // MARK: - Private Properties
    private let event: EventDocument
    private let originalTitle: String
    private let originalDate: Date
    private let originalTime: Date
    private let originalLocation: String
    private let originalNotes: String
    private var lastSaveTime: Date?
    
    // MARK: - Computed Properties
    var isValid: Bool {
        return !title.trimmingCharacters(in: .whitespaces).isEmpty
    }
    
    var hasChanges: Bool {
        return title != originalTitle ||
               date != originalDate ||
               time != originalTime ||
               location != originalLocation ||
               notes != originalNotes
    }
    
    // MARK: - Initialization
    init(event: EventDocument) {
        self.event = event
        self.title = event.title
        self.date = event.eventDate  // Parse from event.date string
        self.time = event.eventDate  // Parse from event.time string
        self.location = event.location ?? ""
        self.notes = event.notes ?? ""  // Assuming notes field exists
        
        self.originalTitle = event.title
        self.originalDate = event.eventDate
        self.originalTime = event.eventDate
        self.originalLocation = event.location ?? ""
        self.originalNotes = event.notes ?? ""
    }
    
    // MARK: - Public Methods
    func saveChanges() async {
        // Debounce (prevent rapid saves)
        if let lastSave = lastSaveTime, Date().timeIntervalSince(lastSave) < 2.0 {
            print("‚ö†Ô∏è Save debounced (too soon)")
            return
        }
        
        isSaving = true
        defer { isSaving = false }
        
        let db = Firestore.firestore()
        
        do {
            // Format date and time strings
            let dateString = formatDate(date)
            let timeString = formatTime(time)
            
            // Update Firestore
            try await db.collection("events").document(event.id).updateData([
                "title": title,
                "date": dateString,
                "time": timeString,
                "location": location,
                "notes": notes,
                "updatedAt": FieldValue.serverTimestamp()
            ])
            
            lastSaveTime = Date()
            
            // Send system message to chat
            await sendSystemMessage("Updated \(title): New time is \(timeString)")
            
            print("‚úÖ Event updated successfully")
            
        } catch {
            errorMessage = "Failed to save: \(error.localizedDescription)"
            print("‚ùå Event update failed: \(error)")
        }
    }
    
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMMM d"  // e.g., "October 31"
        return formatter.string(from: date)
    }
    
    private func formatTime(_ time: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "h:mma"  // e.g., "7:00PM"
        return formatter.string(from: time).lowercased()
    }
    
    private func sendSystemMessage(_ text: String) async {
        // TODO: Send system message to chat
    }
}
```

**Checklist:**
- [ ] Create file with class structure
- [ ] Add `@Published` properties for form fields
- [ ] Store original values (for `hasChanges` check)
- [ ] Implement `saveChanges()` method
- [ ] Update Firestore with new values
- [ ] Send system message to chat
- [ ] Add debouncing (prevent rapid saves)
- [ ] Handle errors gracefully

---

### **Task 4.2: Create EventEditView**

**File:** `messAI/Views/Events/EventEditView.swift` (NEW)

**Implementation:**
```swift
import SwiftUI

struct EventEditView: View {
    @StateObject private var viewModel: EventEditViewModel
    @Environment(\.dismiss) var dismiss
    
    init(event: EventDocument) {
        _viewModel = StateObject(wrappedValue: EventEditViewModel(event: event))
    }
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Event Details")) {
                    TextField("Event Title", text: $viewModel.title)
                    
                    DatePicker("Date", selection: $viewModel.date, displayedComponents: .date)
                    
                    DatePicker("Time", selection: $viewModel.time, displayedComponents: .hourAndMinute)
                }
                
                Section(header: Text("Optional")) {
                    TextField("Location", text: $viewModel.location)
                    
                    TextEditor(text: $viewModel.notes)
                        .frame(height: 100)
                }
                
                if let error = viewModel.errorMessage {
                    Section {
                        Text(error)
                            .font(.caption)
                            .foregroundColor(.red)
                    }
                }
            }
            .navigationTitle("Edit Event")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        if viewModel.hasChanges {
                            viewModel.showCancelConfirmation = true
                        } else {
                            dismiss()
                        }
                    }
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    if viewModel.isSaving {
                        ProgressView()
                    } else {
                        Button("Save") {
                            Task {
                                await viewModel.saveChanges()
                                dismiss()
                            }
                        }
                        .disabled(!viewModel.isValid)
                    }
                }
            }
            .confirmationDialog("Discard Changes?", isPresented: $viewModel.showCancelConfirmation) {
                Button("Discard", role: .destructive) {
                    dismiss()
                }
                Button("Keep Editing", role: .cancel) {}
            }
        }
    }
}
```

**Checklist:**
- [ ] Create SwiftUI view with Form
- [ ] Add TextField for title
- [ ] Add DatePicker for date
- [ ] Add DatePicker for time
- [ ] Add TextField for location
- [ ] Add TextEditor for notes
- [ ] Add "Cancel" and "Save" buttons
- [ ] Show confirmation dialog if changes exist
- [ ] Disable "Save" if title empty
- [ ] Show loading indicator while saving

---

### **Task 4.3: Add Edit Button to EventDetailView**

**File:** `messAI/Views/Events/EventDetailView.swift`

**Changes:**
```swift
private var actionsSection: some View {
    VStack(spacing: 12) {
        // ... existing buttons ...
        
        // Edit button (creator only)
        if viewModel.isCreator {
            Button(action: {
                viewModel.showEditModal = true
            }) {
                Label("Edit Event", systemImage: "pencil")
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.purple.opacity(0.1))
                    .foregroundColor(.purple)
                    .cornerRadius(10)
            }
        }
    }
    .sheet(isPresented: $viewModel.showEditModal) {
        EventEditView(event: viewModel.event)
    }
}
```

**Checklist:**
- [ ] Add "Edit Event" button (creator only)
- [ ] Open `EventEditView` on tap
- [ ] Test: Edit event, save, see updates

---

### **Task 4.4: Send System Message**

**File:** `messAI/ViewModels/EventEditViewModel.swift`

**Implementation:**
```swift
private func sendSystemMessage(_ text: String) async {
    let db = Firestore.firestore()
    
    do {
        // Create system message document
        let messageData: [String: Any] = [
            "senderId": "system",
            "senderName": "System",
            "text": text,
            "sentAt": FieldValue.serverTimestamp(),
            "type": "system",
            "status": "sent"
        ]
        
        // Add to messages subcollection
        try await db.collection("conversations/\(event.conversationId)/messages")
            .addDocument(data: messageData)
        
        print("‚úÖ System message sent: \(text)")
        
    } catch {
        print("‚ùå Failed to send system message: \(error)")
    }
}
```

**Checklist:**
- [ ] Implement `sendSystemMessage()` method
- [ ] Create system message document
- [ ] Add to conversation's messages subcollection
- [ ] Test: Edit event, see system message in chat

---

### **Task 4.5: Phase 4 Testing**

**Manual Tests:**
- [ ] Open event detail (as creator)
- [ ] See "Edit Event" button
- [ ] Tap "Edit Event"
- [ ] Edit modal opens
- [ ] Change title, date, time
- [ ] Tap "Save"
- [ ] Modal dismisses
- [ ] Event detail refreshes
- [ ] Second device sees update (<500ms)
- [ ] System message appears in chat
- [ ] Ambient Bar updates (if active)

---

## üóëÔ∏è **Phase 5: Event Cancellation** (1 hour)

### **Task 5.1: Implement Cancel Event**

**File:** `messAI/ViewModels/EventDetailViewModel.swift`

**Implementation:**
```swift
func cancelEvent() async {
    let db = Firestore.firestore()
    
    do {
        // Update event status
        try await db.collection("events").document(event.id).updateData([
            "status": "cancelled",
            "cancelledAt": FieldValue.serverTimestamp(),
            "cancelledBy": currentUserId
        ])
        
        // Update local state
        event.status = "cancelled"
        
        // Send system message
        await sendSystemMessage("Cancelled \(event.title)")
        
        print("‚úÖ Event cancelled successfully")
        
    } catch {
        errorMessage = "Failed to cancel event: \(error.localizedDescription)"
        print("‚ùå Event cancellation failed: \(error)")
    }
}

private func sendSystemMessage(_ text: String) async {
    // Same implementation as EventEditViewModel
}
```

**Checklist:**
- [ ] Implement `cancelEvent()` method
- [ ] Update Firestore `status` field
- [ ] Add `cancelledAt` timestamp
- [ ] Add `cancelledBy` user ID
- [ ] Send system message to chat
- [ ] Handle errors gracefully

---

### **Task 5.2: Add Cancel Button to EventDetailView**

**File:** `messAI/Views/Events/EventDetailView.swift`

**Changes:**
```swift
private var actionsSection: some View {
    VStack(spacing: 12) {
        // ... existing buttons ...
        
        // Cancel button (creator only)
        if viewModel.isCreator && !viewModel.event.isCancelled {
            Button(action: {
                viewModel.showCancelConfirmation = true
            }) {
                Label("Cancel Event", systemImage: "trash")
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.red.opacity(0.1))
                    .foregroundColor(.red)
                    .cornerRadius(10)
            }
        }
    }
    .confirmationDialog("Cancel Event", isPresented: $viewModel.showCancelConfirmation) {
        Button("Cancel Event", role: .destructive) {
            Task {
                await viewModel.cancelEvent()
            }
        }
        Button("Keep Event", role: .cancel) {}
    } message: {
        Text("This will cancel the event for all participants. This action cannot be undone.")
    }
}
```

**Checklist:**
- [ ] Add "Cancel Event" button (creator only, red)
- [ ] Show confirmation dialog
- [ ] Call `cancelEvent()` on confirm
- [ ] Test: Cancel event, see confirmation

---

### **Task 5.3: Dismiss Ambient Bars on Cancellation**

**File:** `messAI/ViewModels/ChatViewModel.swift`

**Changes:**
```swift
// In existing event listener
private func startEventListener() {
    // ... existing code ...
    
    // Listen to event status changes
    listener = db.collection("events")
        .whereField("conversationId", isEqualTo: conversationId)
        .addSnapshotListener { [weak self] snapshot, error in
            guard let self = self else { return }
            
            snapshot?.documentChanges.forEach { change in
                do {
                    let event = try change.document.data(as: EventDocument.self)
                    
                    // If event was cancelled, dismiss its Ambient Bar
                    if event.status == "cancelled" {
                        Task { @MainActor in
                            self.dismissOpportunity(for: event.id)
                        }
                    }
                } catch {
                    print("‚ùå Failed to parse event: \(error)")
                }
            }
        }
}

private func dismissOpportunity(for eventId: String) {
    activeOpportunities.removeAll { opportunity in
        return opportunity.data.eventReference == eventId
    }
}
```

**Checklist:**
- [ ] Listen to event status changes
- [ ] If event cancelled, dismiss Ambient Bar
- [ ] Test: Cancel event, verify bars dismiss on all devices

---

### **Task 5.4: Phase 5 Testing**

**Manual Tests:**
- [ ] Open event detail (as creator)
- [ ] Tap "Cancel Event"
- [ ] See confirmation dialog
- [ ] Tap "Confirm"
- [ ] Event status ‚Üí "cancelled"
- [ ] System message appears in chat
- [ ] Ambient Bars dismiss (all users)
- [ ] Event moves to "Past" section in Events List
- [ ] Event shows "Cancelled" badge
- [ ] Second device sees update (<500ms)

---

## ‚ú® **Phase 6: Polish & Edge Cases** (1-2 hours)

### **Task 6.1: Add Loading States**

**File:** `messAI/Views/Events/EventsListView.swift`

**Changes:**
- [ ] Show skeleton view while loading events
- [ ] Add `ProgressView()` for initial load
- [ ] Add shimmer effect (optional)

**File:** `messAI/Views/Events/EventDetailView.swift`

**Changes:**
- [ ] Show loading indicator while fetching display names
- [ ] Disable buttons while saving

---

### **Task 6.2: Add Event Count Badge**

**File:** `messAI/Views/Chat/ChatView.swift`

**Changes:**
```swift
ToolbarItem(placement: .navigationBarTrailing) {
    Button(action: {
        showEventsSheet = true
    }) {
        ZStack {
            Image(systemName: "info.circle")
                .font(.title2)
            
            // Badge for event count
            if viewModel.activeEventCount > 0 {
                Text("\(viewModel.activeEventCount)")
                    .font(.caption2)
                    .foregroundColor(.white)
                    .padding(4)
                    .background(Color.red)
                    .clipShape(Circle())
                    .offset(x: 10, y: -10)
            }
        }
    }
}
```

**File:** `messAI/ViewModels/ChatViewModel.swift`

**Changes:**
- [ ] Add `@Published var activeEventCount: Int = 0`
- [ ] Update count when events change
- [ ] Only count upcoming, non-cancelled events

---

### **Task 6.3: Add Pull-to-Refresh**

**File:** `messAI/Views/Events/EventsListView.swift`

**Changes:**
```swift
.refreshable {
    await viewModel.refresh()
}
```

**Checklist:**
- [ ] Add `.refreshable` modifier to List
- [ ] Implement `refresh()` in ViewModel
- [ ] Test: Pull down, see spinner, list refreshes

---

### **Task 6.4: Add Offline Handling**

**File:** `messAI/ViewModels/EventsListViewModel.swift`

**Changes:**
```swift
func loadEvents() async {
    // Check network
    if !NetworkMonitor.shared.isConnected {
        isOffline = true
        // Load from cache
        let cached = // Load from UserDefaults or local DB
        processEvents(cached)
        return
    }
    
    // Fetch from Firestore
    // ...
}
```

**Checklist:**
- [ ] Check `NetworkMonitor.shared.isConnected`
- [ ] Show "Offline" indicator if offline
- [ ] Load from cache if available
- [ ] Disable edit/cancel actions if offline
- [ ] Auto-retry when connection restored

---

### **Task 6.5: Add Error Handling**

**File:** All ViewModels

**Changes:**
- [ ] Add `@Published var errorMessage: String?`
- [ ] Wrap all async calls in `do/catch`
- [ ] Show user-friendly error messages
- [ ] Log detailed errors to console

**File:** All Views

**Changes:**
- [ ] Display error messages (red text)
- [ ] Add retry buttons for failed operations

---

### **Task 6.6: Add Accessibility**

**All Views:**
- [ ] Add `.accessibilityLabel()` to buttons
- [ ] Add `.accessibilityHint()` where helpful
- [ ] Add `.accessibilityValue()` for dynamic content
- [ ] Test with VoiceOver
- [ ] Support Dynamic Type (large text)

---

### **Task 6.7: Phase 6 Testing**

**Manual Tests:**
- [ ] Loading states show correctly
- [ ] Badge shows event count
- [ ] Pull-to-refresh works
- [ ] Offline handling works
- [ ] Error messages display
- [ ] Retry buttons work
- [ ] VoiceOver reads correctly
- [ ] Large text sizes work

---

## ‚úÖ **Final Testing & Deployment**

### **Comprehensive Testing**

**Scenario 1: End-to-End Event Lifecycle**
- [ ] Create event via Ambient Bar
- [ ] Open Events sheet
- [ ] Tap event ‚Üí See details
- [ ] Edit event ‚Üí Save
- [ ] Add to calendar
- [ ] Change RSVP
- [ ] Cancel event
- [ ] Verify all updates on second device

**Scenario 2: Permissions & Errors**
- [ ] Deny calendar permission ‚Üí See error
- [ ] Turn off network ‚Üí See offline state
- [ ] Try to edit offline ‚Üí See error
- [ ] Restore network ‚Üí Auto-refresh

**Scenario 3: Edge Cases**
- [ ] Create event with minimal info (title only)
- [ ] Create event with all fields
- [ ] Edit event multiple times rapidly
- [ ] Cancel event immediately after creating
- [ ] Leave conversation ‚Üí Can't edit event

**Scenario 4: Real-Time Sync**
- [ ] Two devices, same chat
- [ ] Device 1: Create event
- [ ] Device 2: See event immediately
- [ ] Device 1: Edit event
- [ ] Device 2: See update immediately
- [ ] Device 1: Cancel event
- [ ] Device 2: Ambient Bar dismisses immediately

---

### **Code Review Checklist**

- [ ] All new files follow MVVM architecture
- [ ] All async calls use `async/await` (not callbacks)
- [ ] All Firestore queries have error handling
- [ ] All UI components have accessibility labels
- [ ] All computed properties are efficient (no heavy work)
- [ ] All listeners are properly removed in `deinit`
- [ ] No force unwraps (`!`) without safety checks
- [ ] No implicit optionals (use `guard let` or `if let`)
- [ ] No print statements in production (use logger)
- [ ] No hardcoded strings (use constants)

---

### **Performance Checklist**

- [ ] No N+1 queries (batch fetch display names)
- [ ] No redundant Firestore reads (use listeners)
- [ ] No UI blocking (all async work on background)
- [ ] No memory leaks (use `[weak self]` in closures)
- [ ] Efficient list rendering (use `LazyVStack` if needed)

---

### **Deployment Checklist**

- [ ] All tests passing
- [ ] No linter errors
- [ ] No compiler warnings
- [ ] Build succeeds on iPhone 17
- [ ] Tested on physical device
- [ ] Firebase indexes built
- [ ] Firestore rules updated (if needed)
- [ ] Git commit with clear message
- [ ] Create PR with description
- [ ] Request code review
- [ ] Merge to main after approval

---

## üéØ **Success Criteria (Final)**

**All features working:**
- ‚úÖ Info button ‚Üí Opens Events sheet
- ‚úÖ Events list shows all events (upcoming & past)
- ‚úÖ Tap event ‚Üí Opens Event Detail
- ‚úÖ Add to Calendar works
- ‚úÖ Edit event works (creator only)
- ‚úÖ Cancel event works (creator only)
- ‚úÖ Change RSVP works (participants)
- ‚úÖ Real-time updates (<500ms)
- ‚úÖ System messages sent to chat
- ‚úÖ Ambient Bars update automatically
- ‚úÖ Offline handling works
- ‚úÖ Error handling works
- ‚úÖ VoiceOver support works

**Code quality:**
- ‚úÖ Clean architecture (MVVM)
- ‚úÖ Reusable components
- ‚úÖ Comprehensive error handling
- ‚úÖ Unit tests passing
- ‚úÖ Integration tests passing
- ‚úÖ UI tests passing

**Ready to merge!** üöÄ

---

## üìä **Estimated Timeline**

- **Phase 1:** 2-3 hours (Basic Infrastructure)
- **Phase 2:** 1 hour (Calendar Integration)
- **Phase 3:** 1-2 hours (RSVP Management)
- **Phase 4:** 2-3 hours (Event Editing)
- **Phase 5:** 1 hour (Event Cancellation)
- **Phase 6:** 1-2 hours (Polish & Edge Cases)

**Total:** 8-13 hours (realistic: 10-12 hours with testing)

---

**Let's build this! üéâ**

