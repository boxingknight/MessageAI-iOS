# PR#13: Group Chat Functionality - Testing Guide

**Test Scenarios:** 22 comprehensive tests  
**Test Categories:** Unit (4), Integration (10), Edge Cases (7), Performance (4), Acceptance (5)  
**Required Devices:** 3+ devices/simulators for full testing  
**Estimated Testing Time:** 2-3 hours

---

## Test Categories

### Unit Tests (Model & Service Logic)

#### Test 1: Conversation.isAdmin() - Creator Check
**Purpose:** Verify creator is always admin  
**File:** `Models/Conversation.swift`

**Test Case:**
```swift
func testIsAdmin_Creator() {
    let conversation = Conversation(
        id: "conv123",
        participants: ["user1", "user2", "user3"],
        isGroup: true,
        groupName: "Team",
        groupPhotoURL: nil,
        admins: nil,
        createdBy: "user1",
        lastMessage: "",
        lastMessageAt: Date(),
        createdAt: Date()
    )
    
    XCTAssertTrue(conversation.isAdmin("user1"))   // Creator
    XCTAssertFalse(conversation.isAdmin("user2"))  // Regular participant
    XCTAssertFalse(conversation.isAdmin("user3"))  // Regular participant
}
```

**Expected:** ✅ Creator returns true, others return false

---

#### Test 2: Conversation.isAdmin() - Promoted Admin
**Purpose:** Verify promoted admins are recognized  
**File:** `Models/Conversation.swift`

**Test Case:**
```swift
func testIsAdmin_PromotedAdmin() {
    var conversation = Conversation(
        id: "conv123",
        participants: ["user1", "user2", "user3"],
        isGroup: true,
        groupName: "Team",
        groupPhotoURL: nil,
        admins: ["user2"],  // User2 promoted to admin
        createdBy: "user1",
        lastMessage: "",
        lastMessageAt: Date(),
        createdAt: Date()
    )
    
    XCTAssertTrue(conversation.isAdmin("user1"))   // Creator
    XCTAssertTrue(conversation.isAdmin("user2"))   // Promoted admin
    XCTAssertFalse(conversation.isAdmin("user3"))  // Not admin
}
```

**Expected:** ✅ Creator and promoted admin return true

---

#### Test 3: Conversation.displayName() - Group with Custom Name
**Purpose:** Verify custom group names display correctly  
**File:** `Models/Conversation.swift`

**Test Case:**
```swift
func testDisplayName_GroupWithCustomName() {
    let conversation = Conversation(
        id: "conv123",
        participants: ["user1", "user2", "user3"],
        isGroup: true,
        groupName: "Project Team",  // Custom name
        groupPhotoURL: nil,
        admins: nil,
        createdBy: "user1",
        lastMessage: "",
        lastMessageAt: Date(),
        createdAt: Date()
    )
    let users: [String: User] = [:]
    
    let name = conversation.displayName(currentUserId: "user1", users: users)
    XCTAssertEqual(name, "Project Team")
}
```

**Expected:** ✅ Returns custom group name

---

#### Test 4: Conversation.displayName() - Auto-Generated Name
**Purpose:** Verify auto-generated names work when no custom name  
**File:** `Models/Conversation.swift`

**Test Case:**
```swift
func testDisplayName_GroupAutoGenerated() {
    let conversation = Conversation(
        id: "conv123",
        participants: ["user1", "user2", "user3"],
        isGroup: true,
        groupName: nil,  // No custom name
        groupPhotoURL: nil,
        admins: nil,
        createdBy: "user1",
        lastMessage: "",
        lastMessageAt: Date(),
        createdAt: Date()
    )
    let users: [String: User] = [
        "user2": User(id: "user2", displayName: "Alice", email: "alice@example.com", photoURL: nil, isOnline: false, lastSeen: Date(), createdAt: Date()),
        "user3": User(id: "user3", displayName: "Bob", email: "bob@example.com", photoURL: nil, isOnline: false, lastSeen: Date(), createdAt: Date())
    ]
    
    let name = conversation.displayName(currentUserId: "user1", users: users)
    XCTAssertEqual(name, "Alice, Bob")
}

func testDisplayName_GroupAutoGeneratedLarge() {
    let conversation = Conversation(
        id: "conv123",
        participants: ["user1", "user2", "user3", "user4", "user5", "user6"],
        isGroup: true,
        groupName: nil,
        groupPhotoURL: nil,
        admins: nil,
        createdBy: "user1",
        lastMessage: "",
        lastMessageAt: Date(),
        createdAt: Date()
    )
    let users: [String: User] = [
        "user2": User(id: "user2", displayName: "Alice", email: "", photoURL: nil, isOnline: false, lastSeen: Date(), createdAt: Date()),
        "user3": User(id: "user3", displayName: "Bob", email: "", photoURL: nil, isOnline: false, lastSeen: Date(), createdAt: Date()),
        "user4": User(id: "user4", displayName: "Charlie", email: "", photoURL: nil, isOnline: false, lastSeen: Date(), createdAt: Date()),
        "user5": User(id: "user5", displayName: "Diana", email: "", photoURL: nil, isOnline: false, lastSeen: Date(), createdAt: Date()),
        "user6": User(id: "user6", displayName: "Eve", email: "", photoURL: nil, isOnline: false, lastSeen: Date(), createdAt: Date())
    ]
    
    let name = conversation.displayName(currentUserId: "user1", users: users)
    XCTAssertEqual(name, "Alice, Bob, Charlie, and 2 others")
}
```

**Expected:** ✅ Auto-generates "Alice, Bob" or "Alice, Bob, Charlie, and 2 others"

---

#### Test 5: Message.statusForGroup() - All Read
**Purpose:** Verify aggregate status shows read when all participants read  
**File:** `Models/Message.swift`

**Test Case:**
```swift
func testStatusForGroup_AllRead() {
    let conversation = Conversation(
        id: "conv123",
        participants: ["user1", "user2", "user3"],
        isGroup: true,
        groupName: "Test Group",
        groupPhotoURL: nil,
        admins: nil,
        createdBy: "user1",
        lastMessage: "",
        lastMessageAt: Date(),
        createdAt: Date()
    )
    
    var message = Message(
        id: "msg123",
        conversationId: "conv123",
        senderId: "user1",
        text: "Hello",
        imageURL: nil,
        sentAt: Date(),
        deliveredAt: Date(),
        readAt: Date(),
        status: .sent
    )
    message.deliveredTo = ["user2", "user3"]
    message.readBy = ["user2", "user3"]  // All others read
    
    let status = message.statusForGroup(in: conversation, currentUserId: "user1")
    XCTAssertEqual(status, .read)
}
```

**Expected:** ✅ Returns .read (blue double-check)

---

#### Test 6: Message.statusForGroup() - Partially Delivered
**Purpose:** Verify aggregate status shows delivered when at least one received  
**File:** `Models/Message.swift`

**Test Case:**
```swift
func testStatusForGroup_PartiallyDelivered() {
    let conversation = Conversation(
        id: "conv123",
        participants: ["user1", "user2", "user3"],
        isGroup: true,
        groupName: "Test Group",
        groupPhotoURL: nil,
        admins: nil,
        createdBy: "user1",
        lastMessage: "",
        lastMessageAt: Date(),
        createdAt: Date()
    )
    
    var message = Message(
        id: "msg123",
        conversationId: "conv123",
        senderId: "user1",
        text: "Hello",
        imageURL: nil,
        sentAt: Date(),
        deliveredAt: nil,
        readAt: nil,
        status: .sent
    )
    message.deliveredTo = ["user2"]  // Only one delivered
    message.readBy = []
    
    let status = message.statusForGroup(in: conversation, currentUserId: "user1")
    XCTAssertEqual(status, .delivered)  // Show delivered if at least one
}
```

**Expected:** ✅ Returns .delivered (gray double-check)

---

#### Test 7: Message.statusForGroup() - None Delivered
**Purpose:** Verify aggregate status shows sent when no recipients received  
**File:** `Models/Message.swift`

**Test Case:**
```swift
func testStatusForGroup_NoneDelivered() {
    let conversation = Conversation(
        id: "conv123",
        participants: ["user1", "user2", "user3"],
        isGroup: true,
        groupName: "Test Group",
        groupPhotoURL: nil,
        admins: nil,
        createdBy: "user1",
        lastMessage: "",
        lastMessageAt: Date(),
        createdAt: Date()
    )
    
    let message = Message(
        id: "msg123",
        conversationId: "conv123",
        senderId: "user1",
        text: "Hello",
        imageURL: nil,
        sentAt: Date(),
        deliveredAt: nil,
        readAt: nil,
        status: .sent
    )
    // deliveredTo and readBy are empty
    
    let status = message.statusForGroup(in: conversation, currentUserId: "user1")
    XCTAssertEqual(status, .sent)
}
```

**Expected:** ✅ Returns .sent (single gray checkmark)

---

#### Test 8: ChatService.createGroupConversation() - Success
**Purpose:** Verify group creation works with valid inputs  
**File:** `Services/ChatService.swift`

**Test Case:**
```swift
func testCreateGroupConversation_Success() async throws {
    let chatService = ChatService()
    let participants = ["user1", "user2", "user3"]
    
    let conversation = try await chatService.createGroupConversation(
        participants: participants,
        groupName: "Test Group",
        createdBy: "user1"
    )
    
    XCTAssertTrue(conversation.isGroup)
    XCTAssertEqual(conversation.groupName, "Test Group")
    XCTAssertEqual(conversation.participants.count, 3)
    XCTAssertEqual(conversation.createdBy, "user1")
    XCTAssertTrue(conversation.isAdmin("user1"))
}
```

**Expected:** ✅ Group created successfully with correct fields

---

#### Test 9: ChatService.createGroupConversation() - Too Few Participants
**Purpose:** Verify validation rejects groups with <3 participants  
**File:** `Services/ChatService.swift`

**Test Case:**
```swift
func testCreateGroupConversation_TooFewParticipants() async {
    let chatService = ChatService()
    let participants = ["user1", "user2"]  // Only 2
    
    do {
        _ = try await chatService.createGroupConversation(
            participants: participants,
            groupName: "Test Group",
            createdBy: "user1"
        )
        XCTFail("Should throw groupTooSmall error")
    } catch ChatError.groupTooSmall {
        // Expected
        XCTAssert(true)
    } catch {
        XCTFail("Wrong error thrown: \(error)")
    }
}
```

**Expected:** ✅ Throws `.groupTooSmall` error

---

#### Test 10: ChatService.createGroupConversation() - Too Many Participants
**Purpose:** Verify validation rejects groups with >50 participants  
**File:** `Services/ChatService.swift`

**Test Case:**
```swift
func testCreateGroupConversation_TooManyParticipants() async {
    let chatService = ChatService()
    let participants = (1...51).map { "user\($0)" }  // 51 participants
    
    do {
        _ = try await chatService.createGroupConversation(
            participants: participants,
            groupName: "Test Group",
            createdBy: "user1"
        )
        XCTFail("Should throw groupTooLarge error")
    } catch ChatError.groupTooLarge {
        // Expected
        XCTAssert(true)
    } catch {
        XCTFail("Wrong error thrown: \(error)")
    }
}
```

**Expected:** ✅ Throws `.groupTooLarge` error

---

### Integration Tests (End-to-End Flows)

#### Test 11: Create Group and Send Message (Manual)
**Purpose:** Verify complete group creation and messaging flow  
**Devices:** Device A (User A - creator), Device B (User B), Device C (User C)

**Steps:**
1. **Device A**: Open ChatListView
2. **Device A**: Tap "+" button
3. **Device A**: Select "New Group" from action sheet
4. **Device A**: Select User B and User C from ParticipantSelectionView
5. **Device A**: Verify count shows "2 selected"
6. **Device A**: Tap "Next"
7. **Device A**: Enter group name: "Test Group"
8. **Device A**: Tap "Create Group"
9. **Device A**: Verify ChatView opens with group conversation
10. **Device A**: Verify title shows "Test Group"
11. **Device A**: Send message: "Hello group!"
12. **Device B**: Verify message arrives within 2 seconds
13. **Device B**: Verify message shows in gray bubble (left side)
14. **Device B**: Verify sender name "User A" displays above message
15. **Device C**: Verify same as Device B

**Expected Results:**
- ✅ Group creation flow smooth (3 screens, <10 seconds total)
- ✅ Message delivers to all participants within 2 seconds
- ✅ Sender name displays correctly on recipient devices
- ✅ Device A shows blue bubble (right side), no sender name
- ✅ Devices B and C show gray bubble (left side) with sender name

---

#### Test 12: Group Read Receipts (Manual)
**Purpose:** Verify aggregate read receipts work correctly  
**Devices:** Device A (sender), Device B, Device C

**Steps:**
1. **Device A**: Send message in group: "Read receipt test"
2. **Device A**: Verify shows gray single checkmark (sent)
3. Wait 2 seconds for delivery
4. **Device A**: Verify shows gray double-check (delivered to at least one)
5. **Device B**: Open conversation (auto-marks as read)
6. **Device A**: Verify still shows gray double-check (not all read yet)
7. **Device C**: Open conversation (auto-marks as read)
8. **Device A**: Verify shows blue double-check (all read)

**Expected Results:**
- ✅ Status progresses: gray checkmark → gray double-check → blue double-check
- ✅ Blue only appears when ALL participants read
- ✅ Updates in real-time (<2 seconds per status change)

---

#### Test 13: Add Participant to Existing Group (Manual)
**Purpose:** Verify admins can add new participants  
**Devices:** Device A (admin), Device B, Device D (new participant)

**Steps:**
1. **Device A**: Open existing group conversation
2. **Device A**: Tap navigation title to open GroupInfoView
3. **Device A**: Verify shows "3 participants" initially
4. **Device A**: Tap "Add Participants" button
5. **Device A**: Select User D from contact list
6. **Device A**: Confirm addition
7. **Device A**: Verify participant count increases to "4 participants"
8. **Device A**: Verify User D appears in participant list
9. **Device D**: Verify group appears in chat list
10. **Device D**: Open group conversation
11. **Device D**: Verify can see conversation name and participants
12. **Device A**: Send new message: "Welcome User D!"
13. **Device D**: Verify receives message within 2 seconds
14. **Device D**: Send message: "Thanks!"
15. **Devices A, B**: Verify receive User D's message

**Expected Results:**
- ✅ New participant added successfully
- ✅ New participant receives future messages
- ✅ New participant can send messages
- ✅ All participants see updated count

**Note:** For MVP, new participant does NOT see historical messages (only new ones)

---

#### Test 14: Remove Participant from Group (Manual)
**Purpose:** Verify admins can remove participants  
**Devices:** Device A (admin), Device B, Device C (to be removed)

**Steps:**
1. **Device A**: Open GroupInfoView for group
2. **Device A**: Tap "..." menu on User C's row
3. **Device A**: Select "Remove from Group"
4. **Device A**: Confirm removal
5. **Device A**: Verify User C removed from participant list
6. **Device A**: Verify count decreases to "2 participants"
7. **Device C**: Verify group disappears from chat list
8. **Device C**: Try to access group via deep link (should fail with permission error)
9. **Device A**: Send message: "User C was removed"
10. **Device C**: Verify does NOT receive message

**Expected Results:**
- ✅ Removed user no longer in participant list
- ✅ Removed user loses access to conversation
- ✅ Removed user cannot send or receive messages
- ✅ Firestore security rules block access

---

#### Test 15: Leave Group (Self-Remove) (Manual)
**Purpose:** Verify any participant can leave group  
**Devices:** Device B (leaving), Device A, Device C

**Steps:**
1. **Device B**: Open GroupInfoView for group
2. **Device B**: Scroll to bottom
3. **Device B**: Tap "Leave Group" button (red)
4. **Device B**: Confirm action in alert
5. **Device B**: Verify returns to ChatListView
6. **Device B**: Verify group no longer in chat list
7. **Devices A, C**: Verify participant count decreases
8. **Device A**: Send message: "User B left"
9. **Device B**: Verify does NOT receive message
10. **Device B**: Try to send message (should fail)

**Expected Results:**
- ✅ User B removed from group
- ✅ Group disappears from User B's chat list
- ✅ Remaining participants can continue messaging
- ✅ User B cannot access group anymore

---

#### Test 16: Edit Group Name (Admin) (Manual)
**Purpose:** Verify admins can change group name  
**Devices:** Device A (admin), Device B

**Steps:**
1. **Device A**: Open GroupInfoView
2. **Device A**: Tap edit icon (pencil) next to group name
3. **Device A**: Enter new name: "Updated Group Name"
4. **Device A**: Tap "Save"
5. **Device A**: Verify name updates in GroupInfoView
6. **Device A**: Go back to ChatView
7. **Device A**: Verify navigation title shows "Updated Group Name"
8. **Device A**: Go back to ChatListView
9. **Device A**: Verify conversation row shows "Updated Group Name"
10. **Device B**: Verify conversation name updates automatically within 2 seconds

**Expected Results:**
- ✅ Name updates in all locations (GroupInfoView, ChatView, ChatListView)
- ✅ Other participants see update in real-time
- ✅ Non-admins see updated name but cannot edit

---

#### Test 17: Group with Auto-Generated Name (Manual)
**Purpose:** Verify auto-generated names work when no custom name  
**Devices:** Device A (creator), Device B, Device C

**Steps:**
1. **Device A**: Create new group with User B and User C
2. **Device A**: Leave "Group Name" field EMPTY
3. **Device A**: Tap "Create Group"
4. **Device A**: Verify ChatView title shows "Bob, Charlie" (other participants' names)
5. **Device A**: Verify ChatListView shows "Bob, Charlie"
6. **Device B**: Verify conversation shows "Alice, Charlie" (excluding self)
7. **Device C**: Verify conversation shows "Alice, Bob" (excluding self)
8. **Device A**: Open GroupInfoView
9. **Device A**: Verify can edit name (add custom name later if desired)

**Expected Results:**
- ✅ Group created successfully without custom name
- ✅ Auto-generated name shows other participants (excluding current user)
- ✅ Each user sees different auto-generated name (personalized)
- ✅ Can add custom name later via GroupInfoView

---

#### Test 18: Large Group (10 Participants) (Manual)
**Purpose:** Verify performance with 10-member group  
**Devices:** 10 simulators or physical devices

**Steps:**
1. **Device A**: Create group with 9 other users (10 total)
2. **Device A**: Verify group creation completes within 3 seconds
3. **Device A**: Send message: "Hello everyone!"
4. **All 9 other devices**: Verify message arrives within 3 seconds
5. **Device A**: Scroll through messages (send 20+ messages first)
6. **Device A**: Verify scrolling is smooth (60fps)
7. **Device A**: Open GroupInfoView
8. **Device A**: Verify participant list loads quickly (<1 second)
9. **All devices**: Send rapid-fire messages (5 messages each in 10 seconds)
10. **Device A**: Verify all messages appear in correct order

**Expected Results:**
- ✅ Group creation <3 seconds
- ✅ Message delivery to all 9 participants <3 seconds
- ✅ Scroll performance 60fps
- ✅ GroupInfoView loads quickly
- ✅ Message order preserved with rapid-fire messages

---

#### Test 19: Maximum Group Size (50 Participants) (Manual/Simulated)
**Purpose:** Verify maximum participant limit works  
**Devices:** Device A (creator)

**Steps:**
1. **Device A**: Tap "+" → "New Group"
2. **Device A**: Select 49 contacts (+ creator = 50 total)
3. **Device A**: Verify counter shows "49 of 50 selected"
4. **Device A**: Try to select 50th contact
5. **Device A**: Verify selection blocked (stays at 49)
6. **Device A**: Verify UI shows "Maximum 50 participants"
7. **Device A**: Tap "Next", create group
8. **Device A**: Send message
9. Verify: Message delivers to all 49 recipients within 5 seconds (acceptable delay for large group)

**Expected Results:**
- ✅ Selection blocked at 49 (50 total with creator)
- ✅ Clear feedback about limit
- ✅ Group creates successfully with 50 participants
- ✅ Message delivery <5 seconds (some delay acceptable)

**Note:** If you don't have 50 test users, test validation logic by modifying limit temporarily to 5, verify blocking works, then restore to 50.

---

#### Test 20: Typing Indicators in Group (Manual)
**Purpose:** Verify typing indicators work with multiple users  
**Devices:** Device A, Device B, Device C (all in same group)

**Steps:**
1. **Device B**: Start typing (don't send)
2. **Devices A, C**: Verify see "User B is typing..."
3. **Device C**: Also start typing (now 2 typing)
4. **Device A**: Verify sees "User B, User C are typing..."
5. **Device B**: Send message (stops typing)
6. **Device A**: Verify sees only "User C is typing..."
7. **Device C**: Stop typing (clear text field)
8. **Device A**: Verify typing indicator disappears within 3 seconds

**Expected Results:**
- ✅ Typing indicators appear within 1 second
- ✅ Multiple users typing shows all names (or "User B and 2 others" if 3+)
- ✅ Typing clears when message sent
- ✅ Typing auto-expires after 3 seconds

---

### Edge Cases

#### Test 21: Admin Permissions - Non-Admin Cannot Remove (Manual)
**Purpose:** Verify non-admins cannot manage participants  
**Devices:** Device B (non-admin)

**Steps:**
1. **Device B**: Open GroupInfoView (User B is regular participant, not admin)
2. **Device B**: View participant list
3. **Device B**: Verify does NOT see "..." menu on other participants
4. **Device B**: Verify does NOT see "Add Participants" button
5. **Device B**: If attempt API call directly (hack): Firestore rules block with "permission denied"

**Expected Results:**
- ✅ Non-admins do not see management UI
- ✅ Firestore rules enforce permissions (security layer)
- ✅ API calls from non-admins fail

---

#### Test 22: Creator Leaves Group - Admin Transfer (Manual)
**Purpose:** Verify group survives when creator leaves (if other admins exist)  
**Devices:** Device A (creator/admin), Device B (promoted admin), Device C

**Steps:**
1. **Setup**: Device A promotes User B to admin
2. **Device A**: Open GroupInfoView
3. **Device A**: Tap "Leave Group"
4. **Device A**: Confirm
5. **Device A**: Verify returns to ChatListView, group gone
6. **Device B**: Verify still has access to group
7. **Device B**: Open GroupInfoView
8. **Device B**: Verify sees admin controls (can still add/remove participants)
9. **Device B**: Add new participant to verify admin powers work
10. **Devices B, C**: Continue messaging

**Expected Results:**
- ✅ Creator can leave group
- ✅ Group continues to function for remaining participants
- ✅ Other admins retain management powers
- ✅ Group does not become "unmanaged"

---

#### Test 23: Last Admin Leaves Group (Edge Case - Manual)
**Purpose:** Document behavior when last admin leaves  
**Devices:** Device A (only admin), Device B, Device C

**Steps:**
1. **Device A** (only admin): Leave group
2. **Devices B, C**: Verify can still message each other
3. **Device B**: Open GroupInfoView
4. **Device B**: Verify does NOT see admin controls (add/remove, etc.)
5. **Device B**: Try to add participant (should fail or be blocked)
6. **Devices B, C**: Continue messaging (still works)

**Expected Results:**
- ✅ Group becomes "unmanaged" (no admins)
- ✅ Messaging still works (core functionality preserved)
- ✅ Management locked (no one can add/remove participants)
- ⚠️ Group is essentially "frozen" in terms of membership

**Note:** For MVP, this is acceptable. PR #23 can add "auto-promote longest-standing member" if desired.

---

#### Test 24: Duplicate Group Creation Prevention (Edge Case - Manual)
**Purpose:** Verify system handles duplicate group creation gracefully  
**Devices:** Device A

**Steps:**
1. **Device A**: Create group with User B, User C
2. **Device A**: Go back to ChatListView
3. **Device A**: Try to create ANOTHER group with exact same participants (User B, User C)
4. Behavior depends on implementation:
   - Option A: System detects existing group, navigates to it
   - Option B: System allows creation (two separate groups with same participants)

**Expected Results:**
- Option A (Preferred): ✅ Detect duplicate, navigate to existing group, show toast "Group already exists"
- Option B (Acceptable for MVP): ✅ Allow creation, treat as separate groups

**Note:** Option A is better UX but requires additional logic. Option B is acceptable for MVP, can improve in PR #23.

---

#### Test 25: Group Message Ordering with Multiple Senders (Manual)
**Purpose:** Verify message order is preserved with concurrent senders  
**Devices:** Device A, Device B, Device C (all in same group)

**Steps:**
1. **All devices**: Connected and in same group conversation
2. **Device A**: Send message "A1" at T+0s
3. **Device B**: Send message "B1" at T+0.5s
4. **Device C**: Send message "C1" at T+1s
5. **Device A**: Send message "A2" at T+1.5s
6. **Device B**: Send message "B2" at T+2s
7. **All devices**: Verify see messages in order: A1 → B1 → C1 → A2 → B2
8. **All devices**: Verify timestamps are consistent (based on server time)

**Expected Results:**
- ✅ Message order preserved across all devices
- ✅ Timestamps consistent (use serverTimestamp)
- ✅ No "out of order" messages
- ✅ No duplicates

---

#### Test 26: Group with Offline Participant (Manual)
**Purpose:** Verify offline participants receive messages when they reconnect  
**Devices:** Device A, Device B (online), Device C (offline)

**Steps:**
1. **Device C**: Put in airplane mode (offline)
2. **Device A**: Send 3 messages: "Message 1", "Message 2", "Message 3"
3. **Device B**: Verify receives all 3 messages
4. **Device C**: Still offline (messages queued in Firestore)
5. Wait 30 seconds
6. **Device C**: Disable airplane mode (come online)
7. **Device C**: Open app
8. **Device C**: Verify receives all 3 messages in order
9. **Device A**: Verify read receipts update when Device C reads messages

**Expected Results:**
- ✅ Offline participant receives all messages upon reconnect
- ✅ Message order preserved
- ✅ Read receipts update when offline participant reads

---

#### Test 27: Group with Single Active Participant (Edge Case - Manual)
**Purpose:** Verify behavior when only 1 participant remains  
**Devices:** Device A, Device B, Device C

**Steps:**
1. **Setup**: Group with A, B, C
2. **Device B**: Leave group
3. **Device C**: Leave group
4. **Device A**: Only member remaining
5. **Device A**: Verify group still visible in chat list
6. **Device A**: Open conversation
7. **Device A**: Verify can read old messages
8. **Device A**: Try to send message
9. Expected: Message sends to Firestore, but no one to receive it
10. **Device A**: Verify UI shows "You're the only member" (optional)

**Expected Results:**
- ✅ Single-member group doesn't crash
- ✅ Can read historical messages
- ✅ Can send messages (but pointless)
- ⚠️ UI could show helpful message: "You're the only member. Add participants or leave group."

**Note:** This is an edge case. For MVP, as long as it doesn't crash, it's acceptable.

---

### Performance Tests

#### Test 28: Group Creation Speed (Automated/Manual)
**Purpose:** Verify group creation is fast  
**Devices:** Device A

**Steps:**
1. **Device A**: Start timer
2. **Device A**: Tap "+" → "New Group"
3. **Device A**: Select 3 contacts
4. **Device A**: Tap "Next"
5. **Device A**: Enter group name
6. **Device A**: Tap "Create Group"
7. **Device A**: Stop timer when ChatView appears

**Target:** <2 seconds from "Create Group" tap to ChatView appearing

**Expected Results:**
- ✅ Total time <2 seconds (feels instant)
- ✅ No visible lag or loading spinner

---

#### Test 29: Large Group Message Delivery (Automated/Manual)
**Purpose:** Verify message delivery scales to 50 participants  
**Devices:** 50 simulators/devices (or simulated)

**Steps:**
1. **Setup**: Group with 50 participants
2. **Device A**: Start timer
3. **Device A**: Send message: "Delivery test"
4. **Monitor**: Time until ALL 49 other devices receive
5. **Stop timer**: When 49th device receives message

**Target:** <5 seconds for all 49 participants

**Expected Results:**
- ✅ All participants receive within 5 seconds
- ✅ Firestore handles 50 concurrent listeners
- ✅ No participants miss message

**Note:** Some variance expected (network latency, device performance). 5 seconds is conservative for large groups.

---

#### Test 30: Group List Rendering with 100 Groups (Simulated)
**Purpose:** Verify ChatListView handles many groups efficiently  
**Devices:** Device A

**Steps:**
1. **Setup**: User A in 100 group conversations (simulated data)
2. **Device A**: Open ChatListView
3. **Device A**: Scroll rapidly through entire list
4. **Monitor**: Frame rate with Xcode debug overlay
5. **Measure**: Scrolling FPS

**Target:** 60fps scrolling

**Expected Results:**
- ✅ Scroll performance 60fps
- ✅ LazyVStack efficiently handles 100+ conversations
- ✅ No visible lag or frame drops

**Note:** If performance issues, optimize with pagination or limit to 50 groups per query.

---

#### Test 31: GroupInfoView Load Time (Manual)
**Purpose:** Verify GroupInfoView opens quickly  
**Devices:** Device A

**Steps:**
1. **Device A**: Open group conversation (10+ participants)
2. **Device A**: Start timer
3. **Device A**: Tap navigation title
4. **Device A**: Stop timer when GroupInfoView fully rendered

**Target:** <500ms

**Expected Results:**
- ✅ Opens within 500ms
- ✅ Participant list loads quickly
- ✅ No loading spinner (or very brief <200ms)

---

### Acceptance Criteria Tests

#### Test 32: Full Group Flow (Manual - E2E)
**Purpose:** Complete end-to-end group chat experience  
**Devices:** Device A (creator), Device B, Device C

**Scenario:** Weekend planning group

**Steps:**
1. **Device A**: Tap "+" → "New Group"
2. **Device A**: Select User B and User C
3. **Device A**: Name group "Weekend Plans"
4. **Device A**: Create group
5. **Device A**: Send: "Hey everyone! Movie Saturday?"
6. **Devices B, C**: Receive message within 2 seconds
7. **Device B**: Reply: "Yes! What time?"
8. **Device A**: See "User B" above reply
9. **Device C**: Reply: "I'm in! 7pm?"
10. **Device A**: Reply: "Perfect! See you then 🎬"
11. **All devices**: Verify messages show sender names (except own)
12. **Device A**: Tap group name
13. **Device A**: Open GroupInfoView
14. **Device A**: View participant list (3 people)
15. **Device A**: Close and continue chatting

**Success Criteria:**
- ✅ Group creation smooth and intuitive (3 taps)
- ✅ Messages deliver instantly (<2s)
- ✅ Sender names always visible
- ✅ Read receipts work (blue when all read)
- ✅ Navigation feels natural
- ✅ Everything is responsive and fast
- ✅ Feels like WhatsApp/iMessage quality

**Overall:** ✅ User would be confident using this app for real group coordination

---

## Testing Checklist

### Pre-Testing Setup
- [ ] Create 5+ test users in Firebase Auth
- [ ] Verify all test users can sign in
- [ ] Have 3+ physical devices or simulators ready
- [ ] Ensure stable network connection
- [ ] Clear app data on all devices (fresh state)

### Unit Tests (30 minutes)
- [ ] Run all 10 unit tests in Xcode (⌘U)
- [ ] Verify all pass with 100% success rate
- [ ] Fix any failing tests before proceeding

### Integration Tests (60-90 minutes)
- [ ] Test 11: Create group and send message ✓
- [ ] Test 12: Group read receipts ✓
- [ ] Test 13: Add participant ✓
- [ ] Test 14: Remove participant ✓
- [ ] Test 15: Leave group ✓
- [ ] Test 16: Edit group name ✓
- [ ] Test 17: Auto-generated name ✓
- [ ] Test 18: Large group (10 participants) ✓
- [ ] Test 19: Maximum size (50 participants) ✓
- [ ] Test 20: Typing indicators in group ✓

### Edge Cases (30-45 minutes)
- [ ] Test 21: Non-admin permissions ✓
- [ ] Test 22: Creator leaves with other admins ✓
- [ ] Test 23: Last admin leaves ✓
- [ ] Test 24: Duplicate group prevention ✓
- [ ] Test 25: Message ordering ✓
- [ ] Test 26: Offline participant ✓
- [ ] Test 27: Single active participant ✓

### Performance Tests (30 minutes)
- [ ] Test 28: Group creation speed <2s ✓
- [ ] Test 29: Large group delivery <5s ✓
- [ ] Test 30: Group list rendering 60fps ✓
- [ ] Test 31: GroupInfoView load <500ms ✓

### Acceptance Test (20 minutes)
- [ ] Test 32: Full group flow E2E ✓
- [ ] Verify overall UX feels polished
- [ ] Confirm you would use this app yourself

---

## Bug Tracking

**If bugs found during testing:**

1. **Document immediately:**
   - Symptom (what you see)
   - Steps to reproduce
   - Expected vs actual behavior
   - Device/OS version

2. **Prioritize:**
   - CRITICAL: Blocks core functionality (can't create groups, messages don't send)
   - HIGH: Major UX issue (read receipts broken, UI crashes)
   - MEDIUM: Minor issue (typo, slight delay)
   - LOW: Edge case (rare scenario, doesn't affect most users)

3. **Fix in order:**
   - CRITICAL first
   - HIGH next
   - MEDIUM/LOW if time permits (or defer to PR #23)

4. **Re-test after fix:**
   - Run specific test that found bug
   - Run related tests (ensure fix didn't break something else)

---

## Success Criteria

**Feature is complete when:**

### Functional
- [ ] All 22 test scenarios pass
- [ ] Zero CRITICAL or HIGH bugs
- [ ] Group creation works smoothly
- [ ] Messages deliver to all participants
- [ ] Read receipts aggregate correctly
- [ ] Admin permissions enforced

### Performance
- [ ] Group creation <2 seconds
- [ ] Message delivery <3 seconds (10 participants)
- [ ] Message delivery <5 seconds (50 participants)
- [ ] Scroll performance 60fps
- [ ] GroupInfoView loads <500ms

### UX
- [ ] Feels intuitive (no user confusion)
- [ ] Sender names always visible
- [ ] Navigation smooth and logical
- [ ] Errors handled gracefully (no crashes)
- [ ] Would personally use this app

---

**Testing Complete!** ✅

If all tests pass, PR #13 is ready to merge! 🎉

**Next:** Write complete summary, update memory bank, celebrate! 🍾

