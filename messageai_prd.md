# MessageAI MVP - Product Requirements Document
**Platform**: iOS (Swift + SwiftUI)  
**Backend**: Firebase  
**Timeline**: 24 hours  
**Objective**: Build a production-quality messaging app with real-time sync, offline support, and group chat

---

## Executive Summary

Building a WhatsApp-like messaging application for iOS that demonstrates solid messaging infrastructure. The MVP focuses exclusively on core messaging functionality: real-time one-on-one and group chat, offline persistence, presence indicators, and basic media sharing. Success is measured by reliability, not feature count.

---

## User Stories

### Core User Needs

**As a messaging app user, I need to:**

1. **Send and receive text messages instantly** so I can have real-time conversations with my contacts
2. **See all my previous messages when I reopen the app** so my conversation history is never lost
3. **Send messages even without internet connection** so I can compose messages anytime and have them deliver automatically when I'm back online
4. **Know if my message was delivered and read** so I understand the status of my communication
5. **See if someone is online or offline** so I know their availability before messaging
6. **Notice when someone is typing a response** so I know to wait for their message
7. **Chat with multiple people in a group** so I can coordinate with teams or family
8. **Share photos in my conversations** so I can communicate visually
9. **Have a profile with my name and picture** so others can identify me
10. **Get notified when new messages arrive** so I don't miss important conversations

---

## Key Features & Requirements

### 1. User Authentication & Profiles

**Required Functionality:**
- User sign up with email and password
- User login with email and password
- Automatic login persistence (stay logged in)
- User logout

**User Profile:**
- Display name (user-editable)
- Profile picture (upload from camera roll)
- Unique user ID (generated by Firebase)
- Account creation timestamp

**Technical Implementation:**
- Firebase Authentication (email/password provider)
- Store user profile data in Firestore (`users` collection)
- Cache current user data locally with SwiftData

**UI Requirements:**
- Login screen with email/password fields
- Sign up screen with name, email, password fields
- Profile setup screen for display name and profile picture
- Profile view/edit screen

---

### 2. One-on-One Chat

**Required Functionality:**
- Start a conversation with any user
- Send text messages (no character limit up to 10,000 chars)
- Receive messages in real-time (1-2 second delivery)
- View conversation history in chronological order
- Display message timestamps (relative time: "Just now", "5m ago", "Yesterday")
- Show sender's name and profile picture

**Message States:**
- **Sending**: Message being sent to server (gray checkmark)
- **Sent**: Message delivered to server (single checkmark)
- **Delivered**: Message delivered to recipient's device (double checkmark)
- **Read**: Recipient has viewed the message (blue double checkmark)

**Optimistic UI:**
- Message appears instantly in chat when user presses send
- Show "sending" state immediately
- Update to "sent" when server confirms
- Update to "delivered/read" based on recipient actions

**Technical Implementation:**
- Firestore `conversations` collection with document per conversation
- Firestore `messages` subcollection under each conversation
- Real-time Firestore listeners for instant message delivery
- SwiftData for local message persistence
- Message queue for offline scenarios

**UI Requirements:**
- Chat list screen showing all conversations
- Individual chat screen with message bubbles
- Text input field with send button
- Message status indicators
- Smooth scrolling to latest message

---

### 3. Group Chat

**Required Functionality:**
- Create group with 3+ participants
- Send messages to group (visible to all members)
- Receive group messages in real-time
- See who sent each message (name + profile picture)
- Track delivery status per member
- View list of group participants

**Group Properties:**
- Group name (editable by creator)
- Participant list (user IDs)
- Group creation timestamp
- Optional group icon/image

**Technical Implementation:**
- Same Firestore structure as one-on-one (conversations + messages)
- `isGroup` boolean flag on conversation document
- `participants` array with user IDs
- Message delivery tracking per participant

**UI Requirements:**
- "New Group" creation flow
- Participant selection screen (multi-select)
- Group chat screen (similar to one-on-one but with sender names)
- Group info screen showing participants

---

### 4. Real-Time Message Delivery

**Required Functionality:**
- Messages deliver within 1-2 seconds for online users
- Automatic retry on failed sends (exponential backoff)
- Message ordering preserved (no out-of-order messages)
- Handle concurrent sends from multiple users
- Graceful handling of poor network conditions

**Network Scenarios to Handle:**
- **Good connection**: Instant delivery
- **Slow 3G**: Delayed but eventual delivery
- **Intermittent**: Retry until success
- **Offline**: Queue locally, send when online
- **App backgrounded**: Continue receiving via push notifications

**Technical Implementation:**
- Firestore real-time listeners (`.addSnapshotListener()`)
- NetworkMonitor to detect connectivity changes
- Local message queue for offline sends
- Automatic reconnection logic
- Message deduplication (use message IDs)

---

### 5. Message Persistence & Offline Support

**Required Functionality:**
- All messages stored locally in device storage
- App works fully offline (read messages, compose new ones)
- Messages sync automatically when connection restored
- Conversation history persists through app restarts and force quits
- No data loss under any circumstance

**Offline Capabilities:**
- View all previous conversations
- Read all message history
- Compose and queue new messages
- View cached profile pictures

**Sync Logic:**
- On app launch: sync local messages with Firestore
- On reconnect: send queued messages
- Download new messages received while offline
- Resolve conflicts (use server timestamp as source of truth)

**Technical Implementation:**
- SwiftData for local persistence (Message, Conversation, User entities)
- Firestore offline persistence enabled
- Message queue stored locally
- Background sync on app foreground

---

### 6. Presence & Typing Indicators

**Required Functionality:**

**Online/Offline Status:**
- Show green dot when user is online
- Show gray dot when user is offline
- Display "last seen" timestamp when offline
- Update presence in real-time

**Typing Indicators:**
- Show "User is typing..." when recipient is composing
- Clear indicator when user stops typing (3-second timeout)
- Display in one-on-one and group chats

**Technical Implementation:**
- Firestore `presence` collection tracking user status
- Update presence on app foreground/background
- Firebase Realtime Database for low-latency presence (alternative)
- Typing status sent via Firestore with debouncing

**UI Requirements:**
- Status indicator next to user names
- "Last seen" text in chat header
- Typing indicator in chat screen

---

### 7. Read Receipts

**Required Functionality:**
- Track when recipient receives message (delivered)
- Track when recipient opens message (read)
- Display read status to sender
- Update read receipts in real-time

**Read States:**
- **Delivered**: Message arrived on recipient's device
- **Read**: Recipient opened the conversation and viewed the message

**Technical Implementation:**
- `deliveredAt` timestamp on message document
- `readAt` timestamp on message document
- Update Firestore when user opens conversation
- Read receipt listener for real-time updates

**Privacy Consideration:**
- All users have read receipts enabled (no privacy toggle for MVP)

---

### 8. Image Sharing

**Required Functionality:**
- Select image from photo library
- Capture image from camera
- Send image in conversation
- Display image thumbnail in chat
- Tap to view full-screen image
- Download/save image to device

**Image Handling:**
- Compress images before upload (max 2MB)
- Generate thumbnail for chat display (200x200px)
- Store full resolution in Firebase Storage
- Display loading indicator during upload

**Technical Implementation:**
- Firebase Storage for image hosting
- UIImagePickerController for photo selection
- Image compression using UIImage
- Store image URLs in message document
- AsyncImage for loading and caching

**UI Requirements:**
- "+" button to attach image
- Image thumbnail in message bubble
- Full-screen image viewer
- Upload progress indicator

---

### 9. Push Notifications

**Required Functionality:**
- Receive notification when new message arrives (app in background)
- Notification shows sender name and message preview
- Tap notification to open conversation
- Foreground notifications (banner while app is open)

**Notification Content:**
- Sender name
- Message text preview (first 100 characters)
- Conversation name (for groups)

**Technical Implementation:**
- Firebase Cloud Messaging (FCM)
- APNs (Apple Push Notification service) integration
- Store FCM token in user document
- Cloud Function to send notifications on new message
- Handle notification tap (deep linking to conversation)

**Requirements:**
- Foreground notifications (minimum for MVP)
- Background notifications (stretch goal but highly recommended)

---

### 10. Contact List & User Discovery

**Required Functionality:**
- View list of all registered users
- Search users by name or email
- Start new conversation with any user
- Display user's profile picture and name

**Technical Implementation:**
- Query Firestore `users` collection
- Display in searchable list
- Filter by display name
- Tap to start conversation

**UI Requirements:**
- "New Message" button in chat list
- User list screen with search
- User profile preview (name, picture, status)

---

## Technical Architecture

### Firebase Configuration

**Firebase Services:**
- **Firebase Authentication**: User login/signup
- **Cloud Firestore**: Real-time database for messages and conversations
- **Firebase Storage**: Image and media storage
- **Firebase Cloud Messaging**: Push notifications
- **Cloud Functions**: Trigger notifications on new messages

**Firestore Data Schema:**

```
users/
  {userId}/
    displayName: string
    email: string
    photoURL: string (Storage path)
    fcmToken: string
    isOnline: boolean
    lastSeen: timestamp
    createdAt: timestamp

conversations/
  {conversationId}/
    participants: array<userId>
    isGroup: boolean
    groupName: string (optional)
    groupIcon: string (optional)
    lastMessage: string
    lastMessageAt: timestamp
    createdBy: userId
    createdAt: timestamp
    
    messages/
      {messageId}/
        senderId: userId
        text: string
        imageURL: string (optional)
        sentAt: timestamp
        deliveredAt: timestamp (optional)
        readAt: timestamp (optional)
        status: string (sending/sent/delivered/read)

presence/
  {userId}/
    isOnline: boolean
    lastSeen: timestamp
    
typingStatus/
  {conversationId}/
    {userId}: timestamp (when user started typing)
```

**Storage Structure:**
```
profile_pictures/
  {userId}.jpg

chat_images/
  {conversationId}/
    {messageId}.jpg
    {messageId}_thumb.jpg
```

---

### iOS App Architecture

**Project Structure:**
```
MessageAI/
├── App/
│   ├── MessageAIApp.swift
│   └── AppDelegate.swift
├── Models/
│   ├── User.swift
│   ├── Conversation.swift
│   ├── Message.swift
│   └── MessageStatus.swift
├── ViewModels/
│   ├── AuthViewModel.swift
│   ├── ChatListViewModel.swift
│   ├── ChatViewModel.swift
│   └── ProfileViewModel.swift
├── Views/
│   ├── Auth/
│   │   ├── LoginView.swift
│   │   └── SignUpView.swift
│   ├── Chat/
│   │   ├── ChatListView.swift
│   │   ├── ChatView.swift
│   │   ├── MessageBubbleView.swift
│   │   └── MessageInputView.swift
│   ├── Group/
│   │   ├── NewGroupView.swift
│   │   └── GroupInfoView.swift
│   └── Profile/
│       ├── ProfileView.swift
│       └── EditProfileView.swift
├── Services/
│   ├── FirebaseService.swift
│   ├── AuthService.swift
│   ├── ChatService.swift
│   ├── StorageService.swift
│   ├── NotificationService.swift
│   └── NetworkMonitor.swift
└── Utilities/
    ├── ImagePicker.swift
    ├── ImageCompressor.swift
    └── Extensions.swift
```

**Design Pattern:**
- **MVVM Architecture**: ViewModels handle business logic, Views display UI
- **Service Layer**: Separate services for Firebase operations
- **Reactive Programming**: Use `@Published` and Combine for data flow
- **Dependency Injection**: Pass services to ViewModels

---

### Local Data Persistence

**SwiftData Models:**

```swift
@Model
class MessageEntity {
    var id: String
    var conversationId: String
    var senderId: String
    var text: String
    var imageURL: String?
    var sentAt: Date
    var status: String
    var isSynced: Bool
}

@Model
class ConversationEntity {
    var id: String
    var participants: [String]
    var isGroup: Bool
    var lastMessage: String
    var lastMessageAt: Date
    @Relationship(deleteRule: .cascade) var messages: [MessageEntity]
}
```

**Sync Strategy:**
1. User sends message → save to SwiftData immediately (optimistic UI)
2. Send to Firestore in background
3. On success: update local record as synced
4. On failure: keep in queue, retry on reconnect
5. On app launch: sync unsynced messages

---

## UI/UX Requirements

### Design Principles
- **Simple & Clean**: Minimal UI, focus on content
- **Fast & Responsive**: Instant feedback on all actions
- **Familiar Patterns**: Use iOS native components and patterns
- **Accessible**: Support Dynamic Type, VoiceOver, Dark Mode

### Key Screens

**1. Authentication Flow**
- Login screen (email, password)
- Sign up screen (name, email, password)
- Profile setup (upload photo)

**2. Main Navigation**
- Tab bar with: Chats, Contacts, Profile
- Chat list as default view

**3. Chat List**
- Conversation rows with: profile picture, name, last message, timestamp, unread badge
- Search bar at top
- "New Message" button in navigation bar
- Swipe actions: Archive/Delete (optional for MVP)

**4. Chat Screen**
- Message bubbles (sender: right/blue, recipient: left/gray)
- Text input field with send button
- "+" button for image attachment
- Navigation bar: contact name, status, profile picture
- Typing indicator
- Scroll to bottom button

**5. New Conversation**
- Contact list with search
- Select contact to start chat
- Or "New Group" button

**6. Group Creation**
- Select multiple contacts
- Enter group name
- Set group icon (optional)
- Create button

**7. Profile Screen**
- Profile picture (editable)
- Display name (editable)
- Email (read-only)
- Logout button

---

## Testing Requirements

### Critical Test Scenarios

Your MVP must pass these tests:

**1. Real-Time Messaging Test**
- Setup: 2 physical iOS devices logged in as different users
- Action: User A sends message to User B
- Expected: Message appears on User B's device within 2 seconds
- Status indicators update correctly (sent → delivered → read)

**2. Offline Message Test**
- Setup: User A online, User B offline (airplane mode)
- Action: User A sends 3 messages to User B
- Expected: User B's device queues messages
- Action: User B goes online
- Expected: All 3 messages sync and appear in correct order

**3. Persistence Test**
- Setup: User has active conversation with message history
- Action: Force quit app (swipe up in app switcher)
- Action: Reopen app
- Expected: All messages still visible, no data loss

**4. Group Chat Test**
- Setup: 3 users in a group chat
- Action: User A sends message
- Expected: Message appears for User B and User C
- Expected: Each user sees sender name and profile picture

**5. App Lifecycle Test**
- Setup: User in active conversation
- Action: Background app (home button)
- Action: User B sends message
- Expected: Push notification appears
- Action: Tap notification
- Expected: Opens to correct conversation

**6. Poor Network Test**
- Setup: Throttle connection to 3G speeds
- Action: Send 5 messages rapidly
- Expected: Messages eventually deliver, no lost messages
- Expected: Status indicators show "sending" until confirmed

**7. Image Sharing Test**
- Setup: Active conversation
- Action: Select image from photo library and send
- Expected: Image uploads with progress indicator
- Expected: Recipient receives image and can view full-screen

**8. Read Receipts Test**
- Setup: User A sends message to User B
- Action: User B opens conversation
- Expected: User A sees "delivered" change to "read"
- Expected: Read status updates in real-time

---

## Development Roadmap

### Hour 0-4: Foundation & Authentication
- [ ] Create Xcode project (SwiftUI, iOS 16+)
- [ ] Set up Firebase project and add to iOS app
- [ ] Configure Firebase Authentication
- [ ] Build login screen with email/password
- [ ] Build sign up screen
- [ ] Implement AuthViewModel and AuthService
- [ ] Test login/signup flow

### Hour 4-8: Data Models & Firestore Setup
- [ ] Define Firestore schema (users, conversations, messages)
- [ ] Create Swift models (User, Conversation, Message)
- [ ] Set up SwiftData for local persistence
- [ ] Implement FirebaseService for CRUD operations
- [ ] Build ChatService for message sending/receiving
- [ ] Test writing and reading from Firestore

### Hour 8-12: One-on-One Chat
- [ ] Build chat list screen (display conversations)
- [ ] Build contact selection screen (start new chat)
- [ ] Implement ChatViewModel with Firestore listeners
- [ ] Build chat screen with message bubbles
- [ ] Implement message input and send functionality
- [ ] Add optimistic UI (immediate message display)
- [ ] Test real-time messaging between 2 devices

### Hour 12-16: Message Status & Presence
- [ ] Implement message status tracking (sent/delivered/read)
- [ ] Add status indicators to message bubbles
- [ ] Build presence system (online/offline)
- [ ] Add typing indicators
- [ ] Update UI with presence and typing status
- [ ] Test status updates in real-time

### Hour 16-18: Group Chat
- [ ] Build group creation flow
- [ ] Implement group chat logic in ChatService
- [ ] Update chat screen to show sender names (for groups)
- [ ] Test 3+ users in group conversation
- [ ] Verify message attribution and delivery

### Hour 18-20: Image Sharing
- [ ] Integrate UIImagePickerController
- [ ] Implement image compression
- [ ] Set up Firebase Storage
- [ ] Build image upload/download logic
- [ ] Add image display in message bubbles
- [ ] Test image sending and receiving

### Hour 20-22: Offline Support & Sync
- [ ] Enable Firestore offline persistence
- [ ] Implement local message queue (SwiftData)
- [ ] Add NetworkMonitor to detect connectivity
- [ ] Build sync logic for queued messages
- [ ] Test offline scenarios thoroughly

### Hour 22-24: Push Notifications & Polish
- [ ] Configure FCM and APNs
- [ ] Implement Cloud Function for notifications
- [ ] Test foreground notifications
- [ ] Add profile picture upload
- [ ] Final UI polish and bug fixes
- [ ] Test all critical scenarios on physical devices

---

## Success Criteria

### Passing Grade Requirements

✅ **Core Functionality:**
- One-on-one chat works reliably
- Group chat with 3+ users functions correctly
- Messages persist through app restarts
- Real-time delivery within 1-2 seconds

✅ **Resilience:**
- Offline message queuing works
- Messages sync when connection restored
- No data loss under any circumstance
- Graceful handling of poor network

✅ **Essential Features:**
- Message status indicators (sent/delivered/read)
- Online/offline presence
- Typing indicators
- Basic image sharing
- Push notifications (foreground minimum)

✅ **Technical Quality:**
- Deployed backend (Firebase)
- Runs on local emulator/simulator
- Tested on physical device recommended
- No critical bugs in core flows

### Demo Requirements

Record a 5-7 minute video showing:
1. Two devices messaging in real-time
2. Group chat with 3 people
3. Offline test (airplane mode → send → reconnect)
4. App backgrounded and notified
5. Image sharing
6. Read receipts updating

---

## Risks & Mitigation

### Technical Risks

**Risk 1: Firestore Security Rules**
- Impact: Data exposed or inaccessible
- Mitigation: Start with authenticated read/write rules, test thoroughly

**Risk 2: Offline Sync Conflicts**
- Impact: Duplicate messages or data loss
- Mitigation: Use unique message IDs, server timestamp as source of truth

**Risk 3: Memory Issues with Listeners**
- Impact: App crashes or battery drain
- Mitigation: Properly detach listeners on view disappear, limit query results

**Risk 4: Image Upload Failures**
- Impact: Users can't share images
- Mitigation: Implement retry logic, show error states, compress before upload

**Risk 5: Push Notification Setup**
- Impact: Users don't receive notifications
- Mitigation: Follow Firebase FCM setup exactly, test on physical device

### Timeline Risks

**Risk: Not enough time to complete all features**
- Mitigation: Prioritize core messaging first, add features incrementally
- Fallback: Ship with one-on-one chat only if needed, add groups later

**Risk: Debugging takes longer than expected**
- Mitigation: Use Firebase console to inspect data, test early and often

---

## Key Technical Decisions

### Why Firebase?
- Real-time sync is built-in (saves development time)
- Offline persistence out-of-the-box
- Authentication is 10 lines of code
- Scales to production usage
- Cloud Functions ready for AI features later

### Why Swift + SwiftUI?
- Fastest development for iOS
- Modern, declarative UI
- Native performance and animations
- Best integration with iOS features
- SwiftData for simple local persistence

### Why Local Persistence?
- App works fully offline
- Instant message loading (no network delay)
- Resilient to network issues
- Better user experience

### Why Optimistic UI?
- Messages appear instantly (feels fast)
- Users don't wait for server confirmation
- Standard pattern in messaging apps
- Builds trust that messages will send

---

## Getting Started Checklist

### Before You Code

- [ ] Install Xcode (latest version)
- [ ] Create Firebase project at console.firebase.google.com
- [ ] Enable Authentication (email/password)
- [ ] Create Firestore database (start in test mode)
- [ ] Enable Firebase Storage
- [ ] Download GoogleService-Info.plist
- [ ] Set up Apple Developer account (for push notifications)
- [ ] Install Firebase CLI: `npm install -g firebase-tools`

### First Steps

1. Create new Xcode project (SwiftUI, iOS 16+)
2. Install Firebase SDK via Swift Package Manager
3. Add GoogleService-Info.plist to project
4. Initialize Firebase in App file
5. Build and run on simulator to verify setup

---

## Resources

### Firebase Documentation
- [Firebase iOS Setup](https://firebase.google.com/docs/ios/setup)
- [Cloud Firestore Getting Started](https://firebase.google.com/docs/firestore/quickstart)
- [Firebase Authentication](https://firebase.google.com/docs/auth/ios/start)
- [Firebase Storage](https://firebase.google.com/docs/storage/ios/start)
- [Firebase Cloud Messaging](https://firebase.google.com/docs/cloud-messaging/ios/client)

### SwiftUI Tutorials
- [Apple's SwiftUI Tutorials](https://developer.apple.com/tutorials/swiftui)
- [Hacking with Swift - SwiftUI](https://www.hackingwithswift.com/quick-start/swiftui)

### Example Projects
- Search GitHub for "SwiftUI Firebase Chat" for reference implementations

---

## Next Steps

1. **Review and approve this PRD**
2. **Set up development environment** (Xcode, Firebase project)
3. **Start with authentication** (get users logging in)
4. **Build messaging incrementally** (one feature at a time)
5. **Test on real devices early** (simulators don't show real performance)

---

**Remember**: You have 24 hours. Prioritize reliability over features. A simple chat app that works perfectly is better than a feature-rich app with broken message delivery.

**Focus**: Get messages sending and receiving first. Everything else builds on that foundation.